#!/usr/bin/env bash
set -CeE
set -o pipefail

if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  cat << EOF >&2
WARNING: bash ${BASH_VERSION} does not support several modern safety features.
This script was written with the latest POSIX standard in mind, and was only
tested with modern shell standards. This script may not perform correctly in
this environment.
EOF
  sleep 1
else
  set -u
fi

### These are hooks for Cloud Build to be able to use debug/staging images
### when necessary. Don't set these environment variables unless you're testing
### in CI/CD.
_CI_ASM_IMAGE_LOCATION="${_CI_ASM_IMAGE_LOCATION:=}"; readonly _CI_ASM_IMAGE_LOCATION;
_CI_ASM_IMAGE_TAG="${_CI_ASM_IMAGE_TAG:=}"; readonly _CI_ASM_IMAGE_TAG;
_CI_ASM_PKG_LOCATION="${_CI_ASM_PKG_LOCATION:=}"; readonly _CI_ASM_PKG_LOCATION;
_CI_CLOUDRUN_IMAGE_HUB="${_CI_CLOUDRUN_IMAGE_HUB:=}"; readonly _CI_CLOUDRUN_IMAGE_HUB;
_CI_CLOUDRUN_IMAGE_TAG="${_CI_CLOUDRUN_IMAGE_TAG:=}"; readonly _CI_CLOUDRUN_IMAGE_TAG;
_CI_REVISION_PREFIX="${_CI_REVISION_PREFIX:=}"; readonly _CI_REVISION_PREFIX;
_CI_NO_VALIDATE="${_CI_NO_VALIDATE:=0}"; readonly _CI_NO_VALIDATE;
_CI_NO_REVISION="${_CI_NO_REVISION:=0}"; readonly _CI_NO_REVISION;
_CI_ISTIOCTL_REL_PATH="${_CI_ISTIOCTL_REL_PATH:=}"; readonly _CI_ISTIOCTL_REL_PATH;
_CI_BASE_REL_PATH="${_CI_BASE_REL_PATH:=}"; readonly _CI_BASE_REL_PATH;
_CI_TRUSTED_GCP_PROJECTS="${_CI_TRUSTED_GCP_PROJECTS:=}"; readonly _CI_TRUSTED_GCP_PROJECTS;
_CI_CRC_VERSION="${_CI_CRC_VERSION:=0}"; readonly _CI_CRC_VERSION;
_CI_I_AM_A_TEST_ROBOT="${_CI_I_AM_A_TEST_ROBOT:=0}"; readonly _CI_I_AM_A_TEST_ROBOT;

### Internal variables ###
MAJOR="${MAJOR:=1}"; readonly MAJOR;
MINOR="${MINOR:=11}"; readonly MINOR;
POINT="${POINT:=2}"; readonly POINT;
REV="${REV:=17}"; readonly REV;
CONFIG_VER="${CONFIG_VER:="1-unstable"}"; readonly CONFIG_VER;
K8S_MINOR=0

### File related constants ###
VALIDATION_FIX_FILE_NAME=""
ASM_VERSION_FILE=""
ASM_SETTINGS_FILE=""
ISTIO_FOLDER_NAME=""
ISTIOCTL_REL_PATH=""
BASE_REL_PATH=""
PACKAGE_DIRECTORY=""
VALIDATION_FIX_SERVICE=""
OPTIONS_DIRECTORY=""
OPERATOR_MANIFEST=""
BETA_CRD_MANIFEST=""
CITADEL_MANIFEST=""
MANAGED_CNI=""
MANAGED_MANIFEST=""
MANAGED_WEBHOOKS=""
EXPOSE_ISTIOD_DEFAULT_SERVICE=""
EXPOSE_ISTIOD_REVISION_SERVICE=""
CANONICAL_CONTROLLER_MANIFEST=""
EXPANSION_GATEWAY_FILE=""

CRD_CONTROL_PLANE_REVISION=""
CR_CONTROL_PLANE_REVISION_REGULAR=""
CR_CONTROL_PLANE_REVISION_RAPID=""
CR_CONTROL_PLANE_REVISION_STABLE=""
CR_CONTROL_PLANE_REVISION_REGULAR_RECONCILED=""
CR_CONTROL_PLANE_REVISION_RAPID_RECONCILED=""
CR_CONTROL_PLANE_REVISION_STABLE_RECONCILED=""

SCRIPT_NAME="${0##*/}"; readonly SCRIPT_NAME

PROJECT_NUMBER=""
GCLOUD_USER_OR_SA="${GCLOUD_USER_OR_SA:=}"
KPT_URL=""
KUBECONFIG=""
APATH=""
AKUBECTL=""
AKPT=""
AGCLOUD=""
RELEASE=""
REVISION_LABEL=""
REVISION_LABEL_REGULAR=""
REVISION_LABEL_RAPID=""
REVISION_LABEL_STABLE=""
RELEASE_LINE=""
PREVIOUS_RELEASE_LINE=""
KPT_BRANCH=""
RAW_YAML=""
EXPANDED_YAML=""
NAMESPACE_EXISTS=0

main() {
  if [[ "${*}" = '' ]]; then
    usage_short >&2
    exit 2
  fi

  # shellcheck disable=SC2064
  trap "$(shopt -p nocasematch)" RETURN
  shopt -s nocasematch

  context_init
  init
  case "${1}" in
    install)
      shift 1
      install_subcommand "${@}"
      ;;
    apply)
      shift 1
      context_set-option "NON_INTERACTIVE" 1
      install_subcommand "${@}"
      ;;
    validate)
      shift 1
      validate_subcommand "${@}"
      ;;
    print-config)
      shift 1
      print-config_subcommand "${@}"
      ;;
    create-mesh)
      shift 1
      create-mesh_subcommand "${@}"
      ;;
    experimental | x)
      shift 1
      experimental_subcommand "${@}"
      ;;
    *)
      help_subcommand "${@}"
      ;;
  esac
}
create-mesh_subcommand() {
  ### Preparation ###

  # using kubeconfig globally for create-mesh sub-command
  context_set-option "KUBECONFIG_SUPPLIED" 1

  create-mesh_parse_args "$@"
  create-mesh_prepare_environment
  create-mesh_validate_args

  ### Registration ###
  create-mesh_register
  patch_trust_domain_aliases
  install_all_remote_secrets
}

create-mesh_parse_args() {
  if [[ $# -lt 2 ]]; then
    create-mesh_usage_short
    exit 2
  fi

  local FLEET_ID; FLEET_ID="${1}"
  context_set-option "FLEET_ID" "${FLEET_ID}"
  shift 1

  while [[ $# != 0 ]]; do
    case "${1}" in
      -v | --verbose)
        context_set-option "VERBOSE" 1
        shift 1
        ;;
      -h | --help)
        context_set-option "PRINT_HELP" 1
        shift 1
        ;;
      --version)
        context_set-option "PRINT_VERSION" 1
        shift 1
        ;;
      --ignore_workload_identity_mismatch | --ignore-workload-identity-mismatch)
        context_set-option "TRUST_FLEET_IDENTITY" 0
        shift 1
        ;;
      *)
        if [ -f "$1" ]; then
          local KCF; KCF="${1}"
          KCF="$(apath -f "${KCF}")" || fatal "Couldn't find file ${KCF}"
          context_append "kubeconfigFiles" "${KCF}"
        else
          local CLUSTER; CLUSTER="${1}"
          context_append "clustersInfo" "${CLUSTER//\// }"
        fi
        shift 1
        ;;
    esac
  done
  local PRINT_HELP; PRINT_HELP="$(context_get-option "PRINT_HELP")"
  local PRINT_VERSION; PRINT_VERSION="$(context_get-option "PRINT_VERSION")"
  local VERBOSE; VERBOSE="$(context_get-option "VERBOSE")"
  if [[ "${PRINT_HELP}" -eq 1 || "${PRINT_VERSION}" -eq 1 ]]; then
    if [[ "${PRINT_VERSION}" -eq 1 ]]; then
      version_message
    elif [[ "${VERBOSE}" -eq 1 ]]; then
      create-mesh_usage
    else
      create-mesh_usage_short
    fi
    exit
  fi
}

create-mesh_validate_args() {
  local KCF
  local PROJECT_ID
  local CLUSTER_LOCATION
  local CLUSTER_NAME
  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"

  # validate fleet id is valid
  get_project_number "${FLEET_ID}"

  # generate kubeconfig files for each cluster P/L/C
  while read -r PROJECT_ID CLUSTER_LOCATION CLUSTER_NAME; do
    # set KCF to the new kubeconfig
    KCF="$(mktemp)"

    # generate kubeconfig
    info "Fetching/writing GCP credentials to ${KCF}..."
    KUBECONFIG="${KCF}" retry 2 gcloud container clusters get-credentials "${CLUSTER_NAME}" \
      --project="${PROJECT_ID}" \
      --zone="${CLUSTER_LOCATION}"

    # save the kubeconfig to context
    context_append "kubeconfigFiles" "${KCF}"
  done < <(context_list "clustersInfo")

  # required because registration command is different for GCP vs off-GCP clusters
  create-mesh_set_platform

  # validate clusters are valid
  while read -r KCF; do
    context_set-option "KUBECONFIG" "${KCF}"
    context_set-option "CONTEXT" "$(kubectl config current-context)"
    is_cluster_registered
  done <<EOF
$(context_list "kubeconfigFiles")
EOF
}

# Sets the PLATFORM context variable to either {gke|multicloud}
# depending on the kubectl context.
# For a homogeneous mesh, need to be called only once.
# For a hybrid mesh, need to be called for each context change.
create-mesh_set_platform() {
  local FIRST_KCF; FIRST_KCF="$(context_list "kubeconfigFiles" | head -n 1)"
  context_set-option "KUBECONFIG" "${FIRST_KCF}"
  if [[ "$(kubectl config current-context)" =~ "gke_" ]]; then
    context_set-option "PLATFORM" "gcp"
  else
    context_set-option "PLATFORM" "multicloud"
  fi
}

create-mesh_register() {
  while read -r KCF; do
    context_set-option "KUBECONFIG" "${KCF}"
    context_set-option "CONTEXT" "$(kubectl config current-context)"
    if is_gcp; then parse_context; fi
    register_cluster
  done <<EOF
$(context_list "kubeconfigFiles")
EOF
}

parse_context() {
    local PROJECT LOCATION CLUSTER
    IFS="_" read -r _ PROJECT LOCATION CLUSTER <<<"$(context_get-option "CONTEXT")"
    context_set-option "PROJECT_ID" "${PROJECT}"
    context_set-option "CLUSTER_LOCATION" "${LOCATION}"
    context_set-option "CLUSTER_NAME" "${CLUSTER}"
}

install_all_remote_secrets() {
  while read -r KCF1; do
    while read -r KCF2; do
      if [[ "${KCF1}" != "${KCF2}" ]]; then
        install_one_remote_secret "${KCF1}" "${KCF2}"
      fi
    done <<EOF
$(context_list "kubeconfigFiles")
EOF
  done <<EOF
$(context_list "kubeconfigFiles")
EOF
}

install_one_remote_secret() {
  local KCF1; KCF1="${1}"
  local KCF2; KCF2="${2}"
  local CTX1
  local CTX2
  local SECRET_NAME

  context_set-option "KUBECONFIG" "${KCF1}"
  CTX1="$(kubectl config current-context)"
  SECRET_NAME="${CTX1//_/-}"
  SECRET_NAME="${SECRET_NAME//\./-}"
  SECRET_NAME="${SECRET_NAME//@/-}"
  SECRET_NAME="$(generate_secret_name "${SECRET_NAME}")"
  context_set-option "KUBECONFIG" "${KCF2}"
  local CTX2; CTX2="$(kubectl config current-context)"

  info "Installing remote secret ${SECRET_NAME} on ${KCF2}..."

  retry 2 istioctl x create-remote-secret \
    --kubeconfig="${KCF1}" \
    --context="${CTX1}" \
    --name="${SECRET_NAME}" | \
    kubectl apply --kubeconfig="${KCF2}" --context="${CTX2}" -f -
}

# Need to prepare differently under multicluster environment
# validate_cluster and configure_kubectl will be called in validation
# for each cluster
create-mesh_prepare_environment() {
  set_up_local_workspace

  validate_cli_dependencies

  if is_sa; then
    auth_service_account
  fi

  if needs_asm && needs_kpt; then
    download_kpt
  fi
  readonly AKPT

  if needs_asm; then
    if ! necessary_files_exist; then
      download_asm
    fi
    if should_download_kpt_package; then
      download_kpt_package
    fi
    organize_kpt_files
  fi
}

patch_trust_domain_aliases() {
  local PROJECT_ID
  local CLUSTER_LOCATION
  local CLUSTER_NAME
  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"
  local TRUST_FLEET_IDENTITY; TRUST_FLEET_IDENTITY="$(context_get-option "TRUST_FLEET_IDENTITY")"
  if [[ "$TRUST_FLEET_IDENTITY" -eq 0 ]]; then
    return
  fi
  while read -r PROJECT_ID CLUSTER_LOCATION CLUSTER_NAME; do
    # Off-GCP clusters won't have this info
    if [[ -z "${PROJECT_ID}" || -z "${CLUSTER_LOCATION}" || -z "${CLUSTER_NAME}" ]]; then continue; fi

    configure_kubectl "${PROJECT_ID}" "${CLUSTER_LOCATION}" "${CLUSTER_NAME}"
    local ISTIOD_COUNT; ISTIOD_COUNT="$(get_istio_deployment_count)";
    if [[ "$ISTIOD_COUNT" -ne 0 ]]; then
      info "Check trust domain aliases of cluster gke_${PROJECT_ID}_${CLUSTER_LOCATION}_${CLUSTER_NAME}"
      local REVISION; REVISION="$(retry 2 kubectl -n istio-system get pod -l app=istiod \
        -o jsonpath='{.items[].spec.containers[].env[?(@.name=="REVISION")].value}' 2>/dev/null)"

      if [[ -z "${REVISION}" ]]; then
        warn "$(starline)"
        warn "Couldn't automatically determine the revision for the cluster."
        warn "This is normally benign, but in certain multi-project scenarios cross-project traffic"
        warn "may behave unexpectedly. If this is the case, you may need to re-initialize ASM"
        warn "installations (e.g. by re-running 'asmcli install') to ensure that Fleet workload"
        warn "identity is set up properly."
        warn "$(starline)"
        return
      fi

      local REV_NAME; REV_NAME="istio-${REVISION}"
      if [[ "${REVISION}" = default ]]; then
        REV_NAME="istio"
      fi

      # Patch the configmap of the cluster if it does not include FLEET_ID.svc.id.goog
      if ! has_fleet_alias "${FLEET_ID}" "${REV_NAME}"; then
        info "Patching ${REV_NAME} configmap trustDomainAliases on cluster ${PROJECT_ID}/${CLUSTER_LOCATION}/${CLUSTER_NAME} with ${FLEET_ID}.svc.id.goog"
        local CONFIGMAP_YAML; CONFIGMAP_YAML="$(retry 2 kubectl -n istio-system get configmap "${REV_NAME}" -o yaml)"
        CONFIGMAP_YAML="$(echo "$CONFIGMAP_YAML" | sed '/^    trustDomainAliases:.*/a \    - '"${FLEET_ID}.svc.id.goog"'')"
        echo "$CONFIGMAP_YAML"| kubectl apply -f - || warn "failed to patch the configmap ${REV_NAME}"
      fi
    fi

  done <<EOF
$(context_list "clustersInfo")
EOF
}

has_fleet_alias() {
  local FLEET_ID; FLEET_ID="${1}"
  local REV_NAME; REV_NAME="${2}"
  local RAW_TRUST_DOMAIN_ALIASES; RAW_TRUST_DOMAIN_ALIASES="$(retry 2 kubectl -n istio-system get configmap "${REV_NAME}" \
    -o jsonpath='{.data.mesh}' | sed -e '1,/trustDomainAliases:/ d')"
  local RAW_TRUST_DOMAIN_ALIAS
  while IFS= read -r RAW_TRUST_DOMAIN_ALIAS; do
    if [[ "${RAW_TRUST_DOMAIN_ALIAS}" != *"- "* ]]; then false; return; fi
    if [[ "${RAW_TRUST_DOMAIN_ALIAS}" == *"- ${FLEET_ID}.svc.id.goog"* ]]; then
      return
    fi
  done < <(printf '%s\n' "$RAW_TRUST_DOMAIN_ALIASES")
  false
}
experimental_subcommand() {
  if [[ "${*}" = '' ]]; then
    x_usage >&2
    exit 2
  fi

  case "${1}" in
    vm)
      shift 1
      vm_subcommand "${@}"
      ;;
    install)
      shift 1
      x_install_subcommand "${@}"
      ;;
    mcp-migrate-check)
      shift 1
      x_mcp_migrate_check "${@}"
      ;;
    *)
      x_help_subcommand "${@}"
      ;;
  esac
}
x_help_subcommand() {
  x_usage
}

x_usage() {
  cat << EOF
${SCRIPT_NAME} $(version_message)
usage: ${SCRIPT_NAME} experimental [SUBCOMMAND] [OPTION]...

Use features/services in beta or preview states. Can also be accessed using
'x' as a short version of 'experimental'.

SUBCOMMANDS:
  install                             Install using a Google backend service
                                      instead of client-side tools
  vm                                  Functions to configure a mesh to
                                      allow external VM workloads.
  mcp-migrate-check                   Checks IstioOperator config for
                                      compatibility with a Google managed
                                      control plane and generates new config
                                      where possible.

FLAGS:

  --use_vpcsc                         Install Google-managed control plane in
                                      a VPC Service Control restricted
                                      environment.
EOF
}
x_install_subcommand() {
  x_parse_install_args "${@}"
  context_set-option "PLATFORM" "gcp"
  context_set-option "EXPERIMENTAL" 1
  x_validate_install_args
  prepare_environment

  x_validate_dependencies
  x_configure_package
  x_install
}

x_install() {
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local USE_MANAGED_CNI; USE_MANAGED_CNI="$(context_get-option "USE_MANAGED_CNI")"

  if [[ "${USE_MANAGED_CNI}" -eq 0 ]]; then
    install_mananged_cni_static
  fi
  apply_kube_yamls

  # `kubectl wait` for non-existent resources will return error directly so we wait in loop
  info "Wait for the controlplanerevisions CRD to be installed by AFC. This should take a few minutes if cluster is newly registered."
  for i in {1..10}; do
    if kubectl wait --for condition=established --timeout=10s crd/controlplanerevisions.mesh.cloud.google.com 2>/dev/null; then
      break
    fi
    sleep 10
  done

  install_control_plane_revisions

  outro
  info "Successfully installed ASM."
  return 0
}

x_configure_package() {
  local USE_MANAGED_CNI; USE_MANAGED_CNI="$(context_get-option "USE_MANAGED_CNI")"
  local USE_VPCSC; USE_VPCSC="$(context_get-option "USE_VPCSC")"
  kpt cfg set asm anthos.servicemesh.tag "${RELEASE}"
  if [[ -n "${_CI_ASM_IMAGE_LOCATION}" ]]; then
    kpt cfg set asm anthos.servicemesh.hub "${_CI_ASM_IMAGE_LOCATION}"
  fi
  if [[ -n "${_CI_ASM_IMAGE_TAG}" ]]; then
    kpt cfg set asm anthos.servicemesh.tag "${_CI_ASM_IMAGE_TAG}"
  fi
  if [[ "${USE_MANAGED_CNI}" -eq 1 ]]; then
    kpt cfg set asm anthos.servicemesh.use-managed-cni "true"
  fi
  if [[ "${USE_VPCSC}" -eq 1 ]]; then
    kpt cfg set asm anthos.servicemesh.managed-controlplane.vpcsc.enabled "true"
  fi
}
x_mcp_migrate_check() {
  x_parse_mcp_migrate_args "${@}"
  x_download_istioctl_tarball
  context_set-option "VERBOSE" 1

  local PARAMS
  PARAMS=""
  for yaml_file in $(context_list "istioctlFiles"); do
    PARAMS="${PARAMS} -f ${yaml_file}"
  done

  # shellcheck disable=SC2086
  x_istioctl asm mcp-migrate ${PARAMS}
}

x_parse_mcp_migrate_args() {
  # shellcheck disable=SC2064
  trap "$(shopt -p nocasematch)" RETURN
  shopt -s nocasematch

  while [[ $# != 0 ]]; do
    case "${1}" in
      -f)
        arg_required "${@}"
        if [[ ! -f "${2}" ]]; then
          fatal "Couldn't find yaml file ${2}."
        fi
        context_append "istioctlFiles" "${2}"
        shift 2
        ;;
      *)
        fatal "Unknown option ${1}"
        ;;
    esac
  done
}

x_download_istioctl_tarball() {
  local OS
  case "$(uname)" in
    Linux ) OS="linux-amd64";;
    Darwin) OS="osx";;
    *     ) fatal "$(uname) is not a supported OS.";;
  esac

  info "Downloading ASM.."
  local TARBALL; TARBALL="istio-${RELEASE}-${OS}.tar.gz"
  if [[ -z "${_CI_ASM_PKG_LOCATION}" ]]; then
    curl -L "https://storage.googleapis.com/gke-release/asm/${TARBALL}" \
      | tar xz
  else
    local TOKEN; TOKEN="$(retry 2 gcloud auth print-access-token)"
    run_command curl -L "https://storage.googleapis.com/${_CI_ASM_PKG_LOCATION}/asm/${TARBALL}" \
      --header @- <<EOF | tar xz
Authorization: Bearer ${TOKEN}
EOF
  fi
}

x_istioctl() {
  run_command "$(istioctl_path)" "${@}"
}
x_validate_dependencies() {
  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"

  if can_modify_gcp_apis; then
    enable_gcloud_apis
  elif should_validate; then
    exit_if_apis_not_enabled
  fi

  if can_register_cluster; then
    register_cluster
  elif should_validate; then
    exit_if_cluster_unregistered
  fi

  if can_modify_gcp_components; then
    enable_workload_identity
    if ! is_stackdriver_enabled; then
      enable_stackdriver_kubernetes
    fi
    enable_service_mesh_feature
  else
    exit_if_no_workload_identity
    exit_if_stackdriver_not_enabled
    exit_if_service_mesh_feature_not_enabled
  fi

  get_project_number "${FLEET_ID}"
  if can_modify_cluster_labels; then
    add_cluster_labels
  elif should_validate; then
    exit_if_cluster_unlabeled
  fi

  if can_create_namespace; then
    create_istio_namespace
  elif should_validate; then
    exit_if_istio_namespace_not_exists
  fi
}
vm_subcommand() {
  if [[ "${*}" = '' ]]; then
    vm_usage >&2
    exit 2
  fi

  init_vm
  parse_subcommand_for_vm "$@"
}

init_vm() {
  ASM_REVISIONS=""

  EXPANSION_GATEWAY_NAME="istio-eastwestgateway"; readonly EXPANSION_GATEWAY_NAME
  ASM_REVISION_LABEL_KEY="istio.io/rev"; readonly ASM_REVISION_LABEL_KEY
}

parse_subcommand_for_vm() {
  # shellcheck disable=SC2064
  trap "$(shopt -p nocasematch)" RETURN
  shopt -s nocasematch

  case "${1}" in
    prepare-cluster)
      shift 1
      prepare_cluster_subcommand "${@}"
      ;;
    *)
      error "Unknown subcommand ${1}"
      vm_usage >&2
      exit 2
      ;;
  esac
}

prepare_cluster_subcommand() {
  parse_vm_args "${@}"
  validate_vm_args

  if is_sa; then
    auth_service_account
  fi

  validate_vm_dependencies

  local ONLY_VALIDATE; ONLY_VALIDATE="$(context_get-option "ONLY_VALIDATE")"
  if [[ "${ONLY_VALIDATE}" -eq 1 ]]; then
    info "Successfully validated all prerequistes from this shell."
    exit 0
  fi

  local INSTALL_EXPANSION_GATEWAY; INSTALL_EXPANSION_GATEWAY="$(context_get-option "INSTALL_EXPANSION_GATEWAY")"
  local INSTALL_IDENTITY_PROVIDER; INSTALL_IDENTITY_PROVIDER="$(context_get-option "INSTALL_IDENTITY_PROVIDER")"
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"
  if [[ "${INSTALL_EXPANSION_GATEWAY}" -eq 1 ]] || [[ "${INSTALL_IDENTITY_PROVIDER}" -eq 1 ]]; then
    set_up_local_workspace
    configure_kubectl "${PROJECT_ID}" "${CLUSTER_LOCATION}" "${CLUSTER_NAME}"
    if needs_kpt; then
      download_kpt
    fi
    readonly AKPT
    download_asm
    if [[ "${INSTALL_IDENTITY_PROVIDER}" -eq 1 ]]; then
      install_google_identity_provider
    fi
    if [[ "${INSTALL_EXPANSION_GATEWAY}" -eq 1 ]]; then
      install_expansion_gateway
      expose_istiod_vm
    fi
  fi

  enable_service_mesh_feature
  success_message_prepare_cluster
  return 0
}

validate_vm_dependencies() {
  validate_cli_dependencies

  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local FLEET_ID; FLEET_ID="${PROJECT_ID}"
  context_set-option "FLEET_ID" "${FLEET_ID}"
  get_project_number "${FLEET_ID}"

  validate_asm_cluster
}

validate_asm_cluster() {
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"

  validate_cluster "${PROJECT_ID}" "${CLUSTER_LOCATION}" "${CLUSTER_NAME}"
  configure_kubectl "${PROJECT_ID}" "${CLUSTER_LOCATION}" "${CLUSTER_NAME}"

  exit_if_cluster_unregistered

  validate_asm_installation
  validate_google_identity_provider
}

parse_vm_args() {
  if [[ "${*}" = '' ]]; then
    vm_usage >&2
    exit 2
  fi

  # shellcheck disable=SC2064
  trap "$(shopt -p nocasematch)" RETURN
  shopt -s nocasematch

  while [[ $# != 0 ]]; do
    case "${1}" in
      -l | --cluster_location | --cluster-location)
        arg_required "${@}"
        context_set-option "CLUSTER_LOCATION" "${2}"
        shift 2
        ;;
      -n | --cluster_name | --cluster-name)
        arg_required "${@}"
        context_set-option "CLUSTER_NAME" "${2}"
        shift 2
        ;;
      -p | --project_id | --project-id)
        arg_required "${@}"
        context_set-option "PROJECT_ID" "${2}"
        shift 2
        ;;
      -s | --service_account | --service-account)
        arg_required "${@}"
        context_set-option "SERVICE_ACCOUNT" "${2}"
        shift 2
        ;;
      -k | --key_file | --key-file)
        arg_required "${@}"
        context_set-option "KEY_FILE" "${2}"
        shift 2
        ;;
      --dry_run | --dry-run)
        context_set-option "DRY_RUN" 1
        shift 1
        ;;
      --only_validate | --only-validate)
        context_set-option "ONLY_VALIDATE" 1
        shift 1
        ;;
      -v | --verbose)
        context_set-option "VERBOSE" 1
        shift 1
        ;;
      -h | --help)
        context_set-option "PRINT_HELP" 1
        shift 1
        ;;
      *)
        error "Unknown option ${1}"
        vm_usage >&2
        exit 2
        ;;
    esac
  done

  local PRINT_HELP; PRINT_HELP="$(context_get-option "PRINT_HELP")"
  if [[ "${PRINT_HELP}" -eq 1 ]]; then
    vm_usage
    exit
  fi
}

vm_usage() {
  cat << EOF
${SCRIPT_NAME} $(version_message)
usage: ${SCRIPT_NAME} experimental vm [SUBCOMMAND] [OPTION]...

Set up and prepare Anthos Service Mesh to add VM workloads.

SUBCOMMANDS:
  prepare-cluster                     Prepares the specified cluster to allow
                                      external VM workloads.

OPTIONS:
  -l|--cluster_location  <LOCATION>   The GCP location of the target cluster.
  -n|--cluster_name      <NAME>       The name of the target cluster.
  -p|--project_id        <ID>         The GCP project ID.
  -s|--service_account   <ACCOUNT>    The name of a service account used to
                                      install ASM. If not specified, the gcloud
                                      user currently configured will be used.
  -k|--key_file          <FILE PATH>  The key file for a service account. This
                                      option can be omitted if not using a
                                      service account.

FLAGS:
  -v|--verbose                        Print commands before and after execution.
     --dry_run                        Print commands, but don't execute them.
     --only_validate                  Run validation, but don't install.
  -h|--help                           Show this message and exit.
EOF
}

validate_vm_args() {
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"
  local SERVICE_ACCOUNT; SERVICE_ACCOUNT="$(context_get-option "SERVICE_ACCOUNT")"
  local KEY_FILE; KEY_FILE="$(context_get-option "KEY_FILE")"
  local DRY_RUN; DRY_RUN="$(context_get-option "DRY_RUN")"
  local ONLY_VALIDATE; ONLY_VALIDATE="$(context_get-option "ONLY_VALIDATE")"
  local VERBOSE; VERBOSE="$(context_get-option "VERBOSE")"

  local MISSING_ARGS; MISSING_ARGS=0
  while read -r REQUIRED_ARG; do
    if [[ -z "${!REQUIRED_ARG}" ]]; then
      MISSING_ARGS=1
      warn "Missing value for ${REQUIRED_ARG}"
    fi
    readonly "${REQUIRED_ARG}"
  done <<EOF
CLUSTER_LOCATION
CLUSTER_NAME
PROJECT_ID
EOF

  if [[ "${MISSING_ARGS}" -ne 0 ]]; then
    fatal_with_usage "Missing one or more required options."
  fi

  while read -r FLAG; do
    if [[ "${!FLAG}" -ne 0 && "${!FLAG}" -ne 1 ]]; then
      fatal "${FLAG} must be 0 (off) or 1 (on) if set via environment variables."
    fi
    readonly "${FLAG}"
  done <<EOF
DRY_RUN
ONLY_VALIDATE
VERBOSE
EOF

  if [[ -n "$SERVICE_ACCOUNT" && -z "$KEY_FILE" || -z "$SERVICE_ACCOUNT" && -n "$KEY_FILE" ]]; then
    fatal "Service account and key file must be used together."
  fi

  # since we cd to a tmp directory, we need the absolute path for the key file
  # and yaml file
  if [[ -f "${KEY_FILE}" ]]; then
    KEY_FILE="$(apath -f "${KEY_FILE}")"
    readonly KEY_FILE
  elif [[ -n "${KEY_FILE}" ]]; then
    fatal "Couldn't find key file ${KEY_FILE}."
  fi
}

validate_asm_installation() {
  local ONLY_VALIDATE; ONLY_VALIDATE="$(context_get-option "ONLY_VALIDATE")"

  info "Checking for istio-system namespace..."
  if [ "$(retry 2 kubectl get ns | grep -c istio-system || true)" -eq 0 ]; then
    fatal "istio-system namespace cannot be found in the cluster. Please install Anthos Service Mesh and retry."
  fi

  info "Verifying Anthos Service Mesh installation..."
  local ISTIOD_NAMES
  ISTIOD_NAMES=$(retry 2 kubectl -n istio-system get deploy -lapp=istiod \
    --no-headers -o custom-columns=":metadata.name")
  if [[ -n "${ISTIOD_NAMES}" ]]; then
    for istiod in ${ISTIOD_NAMES}; do
      local CURR_REVISION
      CURR_REVISION="$(retry 2 kubectl get deployment "${istiod}" \
        -n istio-system -ojson | jq -r \
        '.metadata.labels["'"${ASM_REVISION_LABEL_KEY}"'"]')"
      ASM_REVISIONS="${ASM_REVISIONS} ${CURR_REVISION}"
    done
    readonly ASM_REVISIONS
    local EXPANSION_GATEWAY
    EXPANSION_GATEWAY=$(retry 2 kubectl -n istio-system get deploy \
      "${EXPANSION_GATEWAY_NAME}" --no-headers \
      -o custom-columns=":metadata.name" --ignore-not-found=true)
    if [[ -z "${EXPANSION_GATEWAY}" ]]; then
      if [[ "${ONLY_VALIDATE}" -eq 1 ]]; then
        { read -r -d '' MSG; fatal "${MSG}"; } <<EOF || true
${EXPANSION_GATEWAY_NAME} is not found in the cluster.
Please install Anthos Service Mesh with VM support or run the current script
without the --only_validate flag.
EOF
      else
        context_set-option "INSTALL_EXPANSION_GATEWAY" 1
      fi
    fi
  fi
}

validate_google_identity_provider() {
  local ONLY_VALIDATE; ONLY_VALIDATE="$(context_get-option "ONLY_VALIDATE")"

  info "Verifying identity providers in the cluster..."
  if ! is_google_identity_provider_installed; then
    if [[ "${ONLY_VALIDATE}" -eq 1 ]]; then
      { read -r -d '' MSG; fatal "${MSG}"; } <<EOF || true
GCE identity provider is not found in the cluster. Please install Anthos Service
Mesh with VM support to allow the script to register the google identity
provider in your cluster or run the current script without the --only_validate
flag.
EOF
    else
      context_set-option "INSTALL_IDENTITY_PROVIDER" 1
    fi
  fi
}

is_google_identity_provider_installed() {
  if ! is_idp_crd_installed; then
    false
    return
  fi

  if ! retry 2 kubectl get identityproviders.security.cloud.google.com -ojsonpath="{..metadata.name}" \
    | grep -w -q google ; then
    false
  fi
}

is_idp_crd_installed() {
  if [[ "$(retry 2 kubectl get crd identityproviders.security.cloud.google.com -ojsonpath="{..metadata.name}" \
    | grep -w -c identityproviders || true)" -eq 0 ]]; then
    false
  fi
}

install_google_identity_provider() {
  info "Registering GCE Identity Provider in the cluster..."
  retry 3 kubectl apply -f asm/identity-provider/identityprovider-crd.yaml
  retry 3 kubectl apply -f asm/identity-provider/googleidp.yaml
}

install_expansion_gateway() {
  if [[ -n "${_CI_ASM_IMAGE_LOCATION}" ]]; then
    kpt cfg set asm anthos.servicemesh.hub "${_CI_ASM_IMAGE_LOCATION}"
  fi
  if [[ -n "${_CI_ASM_IMAGE_TAG}" ]]; then
    kpt cfg set asm anthos.servicemesh.tag "${_CI_ASM_IMAGE_TAG}"
  fi

  local PARAMS; PARAMS="-f ${EXPANSION_GATEWAY_FILE}"

  if [[ "${_CI_NO_REVISION}" -ne 1 ]]; then
    PARAMS="${PARAMS} --set revision=${REVISION_LABEL}"
  fi

  PARAMS="${PARAMS} --skip-confirmation"

  info "Installing the expansion gateway..."
  # shellcheck disable=SC2086
  retry 5 istioctl install $PARAMS

  # Prevent the stderr buffer from ^ messing up the terminal output below
  sleep 1
  info "...done!"
}

expose_istiod_vm() {
  info "Exposing the control plane for VM workloads..."
  retry 3 kubectl apply -f "${EXPOSE_ISTIOD_DEFAULT_SERVICE}"

  for rev in ${ASM_REVISIONS}; do
    kpt cfg set asm anthos.servicemesh.istiodHostFQDN "istiod-${rev}.istio-system.svc.cluster.local"
    kpt cfg set asm anthos.servicemesh.istiodHost "istiod-${rev}.istio-system.svc"
    kpt cfg set asm anthos.servicemesh.istiod-vs-name "istiod-vs-${rev}"

    retry 3 kubectl apply -f "${EXPOSE_ISTIOD_REVISION_SERVICE}"
  done
}

success_message_prepare_cluster() {
  info "
*****************************
The cluster is ready for adding VM workloads.
Please follow the Anthos Service Mesh for GCE VM user guide to add GCE VMs to
your mesh.
*****************************
"
}
help_subcommand() {
  local PRINT_HELP; PRINT_HELP=0
  local PRINT_VERSION; PRINT_VERSION=0
  local VERBOSE; VERBOSE=0

  while [[ $# != 0 ]]; do
    case "${1}" in
      -v | --verbose)
        VERBOSE=1
        shift 1
        ;;
      -h | --help)
        PRINT_HELP=1
        shift 1
        ;;
      --version)
        PRINT_VERSION=1
        shift 1
        ;;
      *)
        fatal_with_usage "Unknown subcommand ${1}"
        ;;
    esac
  done

  if [[ "${PRINT_HELP}" -eq 1 || "${PRINT_VERSION}" -eq 1 ]]; then
    if [[ "${PRINT_VERSION}" -eq 1 ]]; then
      version_message
    elif [[ "${VERBOSE}" -eq 1 ]]; then
      usage
    else
      usage_short
    fi
    exit
  fi
}

version_message() {
  local VER; VER="${MAJOR}.${MINOR}.${POINT}-asm.${REV}+config${CONFIG_VER}";
  if [[ "${_CI_CRC_VERSION}" -eq 1 ]]; then
    VER="${VER}-$(crc32 "$0")"
  fi
  echo "${VER}"
}

usage() {
  cat << EOF
${SCRIPT_NAME} $(version_message)
usage: ${SCRIPT_NAME} [SUBCOMMAND] [OPTION]...

Set up, validate, and install ASM in a Google Cloud environment.
Single argument options can also be passed via environment variables by using
the ALL_CAPS name. Options specified via flags take precedence over environment
variables.

SUBCOMMANDS:
  install                             Install will attempt a new ASM installation
  validate                            Validate will attempt a new ASM validation
  print-config                        Print Config will attempt to print the configurations used
  create-mesh                         Add multiple clusters to the mesh

OPTIONS:
  -l|--cluster_location  <LOCATION>   The GCP location of the target cluster.
  -n|--cluster_name      <NAME>       The name of the target cluster.
  -p|--project_id        <ID>         The GCP project ID.
  --kc|--kubeconfig <KUBECONFIG_FILE> Path to the kubeconfig file to use for CLI requests.
                                      Required if not supplying --cluster_location,
                                      --cluster_name, --project_id in order to locate
                                      and connect to the intended cluster.
  --ctx|--context        <CONTEXT>    The name of the kubeconfig context to use.
  --fleet_id             <FLEET ID>   The Fleet host project ID. Required for non-GCP
                                      clusters. When not provided for GCP clusters, it
                                      defaults to the cluster's project ID.
  --network_id          <NETWORK ID>  The value for topology.istio.io/network label that
                                      will be applied to the istio-system namespace. For GKE,
                                      defaults to the network name for the cluster. For other
                                      environments, "default" will be used.
  -c|--ca                <CA>         The type of certificate authority to be
                                      used. Defaults to "mesh_ca" for install.
                                      Allowed values for <CA> are {citadel|mesh_ca|gcp_cas}.
  -o|--option            <FILE NAME>  The name of a YAML file in the kpt pkg to
                                      apply. For options, see the
                                      anthos-service-mesh-package GitHub
                                      repo under GoogleCloudPlatform. Files
                                      should be in "asm/istio/options" folder,
                                      and shouldn't include the .yaml extension.
                                      (See https://git.io/JTDdi for options.)
                                      To add multiple files, specify them with
                                      multiple options one at a time.
  -s|--service_account   <ACCOUNT>    The name of a service account used to
                                      install ASM. If not specified, the gcloud
                                      user currently configured will be used.
  -k|--key_file          <FILE PATH>  The key file for a service account. This
                                      option can be omitted if not using a
                                      service account.
  -D|--output_dir        <DIR PATH>   The directory where this script will place
                                      downloaded ASM packages and configuration.
                                      If not specified, a temporary directory
                                      will be created. If specified and the
                                      directory already contains the necessary
                                      files, they will be used instead of
                                      downloading them again.
  --co|--custom_overlay  <FILE PATH>  The location of a YAML file to overlay on
                                      the ASM IstioOperator. This option can be
                                      omitted if not installing optional
                                      features. To add multiple files, specify
                                      them with multiple options one at a time.
  --ca_pool              <CA POOL>    Required only if --ca option is gcp_cas.
                                      Name of the ca pool in the GCP CAS service used to
                                      sign certificates in the format
                                      'projects/project_name/locations/ \
                                      ca_region/caPools/ca_pool'.
  -r|--revision_name <REVISION NAME>  Custom revision label. Label needs to follow DNS
                                      label formats (re: RFC 1123). Not supported if
                                      control plane is managed. Prefixing the revision
                                      name with 'asm' is recommended.
  --platform             <PLATFORM>   The platorm or the provider of the kubernetes
                                      cluster. Defaults to "gcp" (for GKE clusters).
                                      For all other platforms use "multicloud".
                                      Allowed values for <PLATFORM> are {gcp|multicloud}.
  --channel              <CHANNEL>    The release channel for the control plane revision.
                                      If the user specifies the channel to be used, only
                                      the Control Plane Revision associated with this
                                      channel will be provisioned. Otherwise, the mapping
                                      between Multicloud/GKE channel and the ASM Channel is
                                      as following:
                                      For Multicloud:
                                        ASM provisions Regular, Rapid channels.
                                      For GKE:
                                        GKE Channel  |  ASM Channel
                                        -------------|----------------
                                        Rapid        |  Rapid
                                        Regular      |  Regular, Rapid
                                        Stable       |  Stable
                                        Static       |  Regular, Rapid

  The following four options must be passed together and are only necessary
  for using a custom certificate for Citadel. Users that aren't sure whether
  they need this probably don't.

  --ca_cert              <FILE PATH>  The intermediate certificate
  --ca_key               <FILE PATH>  The key for the intermediate certificate
  --root_cert            <FILE PATH>  The root certificate
  --cert_chain           <FILE PATH>  The certificate chain

FLAGS:

  The following several flags all relate to allowing the script to create, set,
  or enable required APIs, roles, or services. These can all be performed
  manually before running the script if desired. To allow the script to perform
  every necessary action, pass the -e|--enable_all flag. All of these flags
  are incompatible with --only_validate.

  -e|--enable_all                     Allow the script to perform all of the
                                      individual enable actions below. (Fleet
                                      registration won't happen unless necessary
                                      for a selected option.)
     --enable_cluster_roles           Allow the script to attempt to set
                                      the necessary cluster roles.
     --enable_cluster_labels          Allow the script to attempt to set
                                      necessary cluster labels.
     --enable_gcp_apis                Allow the script to enable GCP APIs on
                                      the user's behalf
     --enable_gcp_iam_roles           Allow the script to set the required GCP
                                      IAM permissions
     --enable_gcp_components          Allow the script to enable required GCP
                                      managed services and components
     --enable_meshconfig_init         Allow the script to initialize the meshconfig
                                      endpoint on your behalf. Implied by
                                      --enable_gcp_components and --managed.
     --enable_registration            Allow the script to register the cluster
                                      to a fleet
     --enable_namespace_creation      Allow the script to create the istio-system
                                      namespace for the user
     --use_managed_cni                Use managed CNI experience. Experimental install
                                      only. If not passed, asmcli will apply the static
                                      CNI manifests.

     --managed                        Provision a remote, managed control plane
                                      instead of installing one in-cluster.
     --legacy                         Provision a remote, managed control plane with
                                      the legacy asmcli installer that runs client-side.

     --print_config                   Instead of installing ASM, print all of
                                      the compiled YAML to stdout. All other
                                      output will be written to stderr, even if
                                      it would normally go to stdout. Skip all
                                      validations and setup.
     --disable_canonical_service      Do not install the CanonicalService
                                      controller. This is required for ASM UI to
                                      support various features.
  -v|--verbose                        Print commands before and after execution.
     --dry_run                        Print commands, but don't execute them.
     --only_validate                  Run validation, but don't install.
     --only_enable                    Perform the specified steps to set up the
                                      current user/cluster but don't install
                                      anything.
  -h|--help                           Show this message and exit.
  --version                           Print the version of this tool and exit.

EXAMPLE:
The following invocation will install ASM to a cluster named "my_cluster" in
project "my_project" in region "us-central1-c" using the default "mesh_ca" as
the certificate authority:
  $> ${SCRIPT_NAME} \\
      install \\
      -n my_cluster \\
      -p my_project \\
      -l us-central1-c \\

  or

  $> ${SCRIPT_NAME} \\
      install \\
      --kubeconfig kubeconfig_file \\
      --context kube context \\
EOF
}

### CLI/initial setup functions ###
usage_short() {
  cat << EOF
${SCRIPT_NAME} $(version_message)
usage: ${SCRIPT_NAME} [SUBCOMMAND] [OPTION]...

Set up, validate, and install ASM in a Google Cloud environment.
Use -h|--help with -v|--verbose to show detailed descriptions.

SUBCOMMANDS:
  install
  validate
  print-config
  create-mesh

OPTIONS:
  -l|--cluster_location  <LOCATION>
  -n|--cluster_name      <NAME>
  -p|--project_id        <ID>
  --kc|--kubeconfig      <KUBECONFIG_FILE>
  --ctx|--context        <CONTEXT>
  --fleet_id             <FLEET ID>
  --network_id           <NETWORK ID>
  -c|--ca                <CA>

  -o|--option            <FILE NAME>
  -s|--service_account   <ACCOUNT>
  -k|--key_file          <FILE PATH>
  -D|--output_dir        <DIR PATH>
  --co|--custom_overlay  <FILE NAME>

  --ca_cert              <FILE PATH>
  --ca_key               <FILE PATH>
  --root_cert            <FILE PATH>
  --cert_chain           <FILE PATH>
  --ca_pool              <CA POOL>
  -r|--revision_name     <REVISION NAME>
  --platform             <PLATFORM>
  --channel              <CHANNEL>

FLAGS:
  -e|--enable_all
     --enable_cluster_roles
     --enable_cluster_labels
     --enable_gcp_apis
     --enable_gcp_iam_roles
     --enable_gcp_components
     --enable_meshconfig_init
     --enable_registration
     --enable_namespace_creation
     --use_managed_cni

     --managed
     --legacy

     --print_config
     --disable_canonical_service
  -v|--verbose
     --dry_run
     --only_validate
     --only_enable
  -h|--help
  --version
EOF
}

create-mesh_usage() {
  cat << EOF
${SCRIPT_NAME} $(version_message)
usage: ${SCRIPT_NAME} create-mesh FLEET_ID (PROJECT_ID/CLUSTER_LOCATION/CLUSTER_NAME | KUBECONFIG_PATH) ... 

Create a multi-cluster service mesh and allow cross-cluster service discovery. This is done by
registering the clusters to the specified fleet and installing the necessary Kubernetes cluster
secrets to allow ASM to communicate securely.

You can pass in an arbitrary number of clusters at once, either by specifying the project ID,
cluster location, and cluster name (for GKE on GCP clusters only) or the location of a
kubeconfig file that has the default context set to the desired cluster.

When adding/removing clusters to an existing multi-cluster fleet, you must specify the entire set
of clusters for every invocation. You cannot add or remove clusters one at a time.

This command will fail if any of the specified clusters are registered to a fleet other than the one
specified by FLEET_ID.

FLAGS:
  The following several flags are used to display help texts and the version message.
  -v|--verbose                        Print commands before and after execution.
  -h|--help                           Show this message and exit.
  --version                           Print the version of this tool and exit.

EXAMPLE:
The following invocation will create a mesh using the provided 6 clusters
by registering them to a fleet named "my_cluster" and install remote secrets on each pair of clusters:

  $> ${SCRIPT_NAME} \\
      create-mesh \\
      my-fleet \\
      my-project/us-central1-c/my-cluster1 \\
      path/to/kubeconfig2 \\
      my-project/us-central1-c/my-cluster3

EOF
}

create-mesh_usage_short() {
  cat << EOF
${SCRIPT_NAME} $(version_message)
usage: ${SCRIPT_NAME} create-mesh FLEET_ID (PROJECT_ID/CLUSTER_LOCATION/CLUSTER_NAME | KUBECONFIG_PATH) ...

Create a multi-cluster service mesh and allow cross-cluster service discovery.
Use -h|--help with -v|--verbose to show detailed descriptions.

FLAGS:
  -v|--verbose
  -h|--help
  --version
EOF
}
install_subcommand() {
  ### Preparation ###
  parse_args "${@}"
  validate_args
  prepare_environment

  ### Validate ###
  validate

  local USE_VM; USE_VM="$(context_get-option "USE_VM")"
  if [[ "${USE_VM}" -eq 1 ]]; then
    register_gce_identity_provider
  fi

  ### Configure ###
  configure_package
  post_process_istio_yamls

  install
}

install() {
  install_ca
  install_control_plane

  outro
  info "Successfully installed ASM."
  return 0
}

install_in_cluster_control_plane() {
  local USE_VM; USE_VM="$(context_get-option "USE_VM")"

  if ! does_istiod_exist && [[ "${_CI_NO_REVISION}" -ne 1 ]]; then
    info "Installing validation webhook fix..."
    retry 3 kubectl apply --overwrite=true -f "${VALIDATION_FIX_SERVICE}"
  fi

  local PARAMS; PARAMS="$(gen_install_params)"

  if [[ "${_CI_NO_REVISION}" -ne 1 ]]; then
    PARAMS="${PARAMS} --set revision=${REVISION_LABEL}"
  fi

  PARAMS="${PARAMS} --skip-confirmation"

  info "Installing ASM control plane..."
  # shellcheck disable=SC2086
  retry 5 istioctl install $PARAMS

  # Prevent the stderr buffer from ^ messing up the terminal output below
  sleep 1
  info "...done!"

  print_config >| "${RAW_YAML}"
  istioctl manifest generate \
    <"${RAW_YAML}" \
    >|"${EXPANDED_YAML}"

  if [[ "${USE_VM}" -eq 1 ]]; then
    info "Exposing the control plane for VM workloads..."

    expose_istiod
  fi
}

install_private_ca() {
  # This sets up IAM privileges for the project to be able to access GCP CAS.
  # If modify_gcp_component permissions are not granted, it is assumed that the
  # user has taken care of this, else Istio setup will fail
  local CA_NAME; CA_NAME="$(context_get-option "CA_NAME")"
  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"
  local WORKLOAD_IDENTITY; WORKLOAD_IDENTITY="${FLEET_ID}.svc.id.goog:/allAuthenticatedUsers/"
  local CA_LOCATION; CA_LOCATION=$(echo "${CA_NAME}" | cut -f4 -d/)
  local CA_POOL; CA_POOL=$(echo "${CA_NAME}" | cut -f6 -d/)
  local PROJECT; PROJECT=$(echo "${CA_NAME}" | cut -f2 -d/)

  retry 3 gcloud privateca pools add-iam-policy-binding "${CA_POOL}" \
    --project "${PROJECT}" \
    --location "${CA_LOCATION}" \
    --member "group:${WORKLOAD_IDENTITY}" \
    --role "roles/privateca.workloadCertificateRequester"

  retry 3 gcloud privateca pools add-iam-policy-binding "${CA_POOL}" \
    --project "${PROJECT}" \
    --location "${CA_LOCATION}" \
    --member "group:${WORKLOAD_IDENTITY}" \
    --role "roles/privateca.auditor"
}

does_istiod_exist(){
  local RETVAL; RETVAL=0;
  kubectl get service \
    --request-timeout='20s' \
    -n istio-system \
    istiod 1>/dev/null 2>/dev/null || RETVAL=$?
  return "${RETVAL}"
}

apply_kube_yamls() {
  for yaml_file in $(context_list "kubectlFiles"); do
    info "Applying ${yaml_file}..."
    retry 3 kubectl apply --overwrite=true -f "${yaml_file}"
    sleep 2
  done
}

install_canonical_controller() {
  info "Installing ASM CanonicalService controller in asm-system namespace..."
  retry 3 kubectl apply -f "${CANONICAL_CONTROLLER_MANIFEST}"
  info "Waiting for deployment..."
  retry 3 kubectl wait --for=condition=available --timeout=600s \
      deployment/canonical-service-controller-manager -n asm-system
  info "...done!"
}

install_control_plane_revisions() {
  info "Configuring ASM managed control plane revision CR for channels..."
  
  local CHANNEL CR REVISION
  while read -r CHANNEL; do
    read -r CR REVISION<<EOF
$(get_cr_yaml "${CHANNEL}")
EOF
    info "Installing ASM Control Plane Revision CR with ${REVISION} channel in istio-system namespace..."
    retry 3 kubectl apply -f "${CR}"

    if ! is_legacy; then
      info "Waiting for deployment..."
      retry 3 kubectl wait --for=condition=ProvisioningFinished \
        controlplanerevision "${REVISION}" -n istio-system --timeout 600s
    fi
  done <<EOF
$(get_cr_channels)
EOF
}

expose_istiod() {
  # The default istiod service is exposed so that any fallback on the VM side
  # to use the default Istiod service can still connect to the control plane.
  context_append "kubectlFiles" "${EXPOSE_ISTIOD_DEFAULT_SERVICE}"
  context_append "kubectlFiles" "${EXPOSE_ISTIOD_REVISION_SERVICE}"
}

outro() {
  local OUTPUT_DIR; OUTPUT_DIR="$(context_get-option "OUTPUT_DIR")"

  info ""
  info "$(starline)"
  istioctl version
  info "$(starline)"
  info "The ASM control plane installation is now complete."
  info "To enable automatic sidecar injection on a namespace, you can use the following command:"
  info "kubectl label namespace <NAMESPACE> istio-injection- istio.io/rev=${REVISION_LABEL} --overwrite"
  info "If you use 'istioctl install' afterwards to modify this installation, you will need"
  info "to specify the option '--set revision=${REVISION_LABEL}' to target this control plane"
  info "instead of installing a new one."

  info "To finish the installation, enable Istio sidecar injection and restart your workloads."
  info "For more information, see:"
  info "https://cloud.google.com/service-mesh/docs/proxy-injection"

  info "The ASM package used for installation can be found at:"
  info "${OUTPUT_DIR}/asm"
  info "The version of istioctl that matches the installation can be found at:"
  info "${OUTPUT_DIR}/${ISTIOCTL_REL_PATH}"
  info "A symlink to the istioctl binary can be found at:"
  info "${OUTPUT_DIR}/istioctl"
  if ! is_managed; then
    info "The combined configuration generated for installation can be found at:"
    info "${OUTPUT_DIR}/${RAW_YAML}"
    info "The full, expanded set of kubernetes resources can be found at:"
    info "${OUTPUT_DIR}/${EXPANDED_YAML}"
  fi

  info "$(starline)"
}

configure_ca() {
  local CA; CA="$(context_get-option "CA")"
  case "${CA}" in
    mesh_ca) configure_meshca;;
    gcp_cas) configure_private_ca;;
    citadel) configure_citadel;;
  esac
}

configure_control_plane() {
  :
}

install_ca() {
  local CA; CA="$(context_get-option "CA")"
  case "${CA}" in
    mesh_ca) ;;
    gcp_cas) install_private_ca;;
    citadel) install_citadel;;
  esac
}

install_control_plane() {
  local MANAGED; MANAGED="$(context_get-option "MANAGED")"
  local DISABLE_CANONICAL_SERVICE; DISABLE_CANONICAL_SERVICE="$(context_get-option "DISABLE_CANONICAL_SERVICE")"

  label_istio_namespace
  if is_managed; then
    install_managed_control_plane
  else
    install_in_cluster_control_plane
  fi

  apply_kube_yamls

  if is_managed; then
    install_control_plane_revisions
  fi

  if [[ "$DISABLE_CANONICAL_SERVICE" -eq 0 ]]; then
    install_canonical_controller
  fi
}
print-config_subcommand() {
  # make sure to redirect stdout as soon as possible if we're dumping the config
  exec 3>&1
  exec 1>&2

  ### Preparation ###
  context_set-option "PRINT_CONFIG" 1   # used by some validations
  parse_args "${@}"
  validate_args
  prepare_environment

  ### Validate ###
  validate

  local USE_VM; USE_VM="$(context_get-option "USE_VM")"
  if [[ "${USE_VM}" -eq 1 ]]; then
    register_gce_identity_provider
  fi

  ### Configure ###
  configure_package
  post_process_istio_yamls

  local USE_HUB_WIP; USE_HUB_WIP="$(context_get-option "USE_HUB_WIP")"
  if [[ "${USE_HUB_WIP}" -eq 1 ]]; then
    populate_fleet_info
  fi
  print_config >&3
}

print_config() {
  local MANAGED; MANAGED="$(context_get-option "MANAGED")"

  if [[ "${MANAGED}" -eq 1 ]]; then
    cat "${MANAGED_MANIFEST}"
    return
  fi

  local PARAMS; PARAMS="$(gen_install_params)"

  # shellcheck disable=SC2086
  istioctl profile dump ${PARAMS}
}
validate_subcommand() {
  ### Preparation ###
  context_set-option "ONLY_VALIDATE" 1
  parse_args "${@}"
  validate_args
  prepare_environment

  ### Validate ###
  validate
}

validate() {
  local ONLY_VALIDATE; ONLY_VALIDATE="$(context_get-option "ONLY_VALIDATE")"

  validate_hub
  validate_dependencies
  validate_control_plane

  if [[ "${ONLY_VALIDATE}" -ne 0 ]]; then
    local VALIDATION_ERROR; VALIDATION_ERROR="$(context_get-option "VALIDATION_ERROR")"
    if [[ "${VALIDATION_ERROR}" -eq 0 ]]; then
      info "Successfully validated all requirements to install ASM."
      exit 0
    else
      warn "Please see the errors above."
      exit 2
    fi
  fi

  if only_enable; then
    info "Successfully performed specified --enable actions."
    exit 0
  fi
}

validate_dependencies() {
  local USE_HUB_WIP; USE_HUB_WIP="$(context_get-option "USE_HUB_WIP")"
  local USE_VM; USE_VM="$(context_get-option "USE_VM")"
  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"

  if can_modify_gcp_apis; then
    enable_gcloud_apis
  elif should_validate; then
    exit_if_apis_not_enabled
  fi

  if is_gcp; then
    if can_modify_gcp_components; then
      enable_workload_identity
      if ! is_stackdriver_enabled; then
        enable_stackdriver_kubernetes
      fi
      if needs_service_mesh_feature; then
        enable_service_mesh_feature
      fi
    else
      exit_if_no_workload_identity
      exit_if_stackdriver_not_enabled
      if needs_service_mesh_feature; then
        exit_if_service_mesh_feature_not_enabled
      fi
    fi
  fi

  if can_register_cluster; then
    register_cluster
  elif should_validate && [[ "${USE_HUB_WIP}" -eq 1 || "${USE_VM}" -eq 1 ]]; then
    exit_if_cluster_unregistered
  fi

  get_project_number "${FLEET_ID}"
  if is_gcp; then
    if can_modify_cluster_labels; then
      add_cluster_labels
    elif should_validate; then
      exit_if_cluster_unlabeled
    fi
  fi

  if can_modify_cluster_roles; then
    bind_user_to_cluster_admin
  elif should_validate; then
    exit_if_not_cluster_admin
  fi

  if can_create_namespace; then
    create_istio_namespace
  elif should_validate; then
    exit_if_istio_namespace_not_exists
  fi
}

validate_control_plane() {
  if is_managed && is_legacy; then
    # Managed legacy must be able to set IAM permissions on a generated user, so the flow
    # is a bit different
    validate_managed_control_plane_legacy
  elif ! is_managed; then
    validate_in_cluster_control_plane
  fi
}
validate_custom_ca() {
  local CA_ROOT; CA_ROOT="$(context_get-option "CA_ROOT")"
  local CA_KEY; CA_KEY="$(context_get-option "CA_KEY")"
  local CA_CHAIN; CA_CHAIN="$(context_get-option "CA_CHAIN")"
  local CA_CERT; CA_CERT="$(context_get-option "CA_CERT")"

  if [[ "${CA}" != "citadel" ]]; then
    fatal "You must select Citadel as the CA in order to use custom certificates."
  fi
  if [[ -z "${CA_ROOT}" || -z "${CA_KEY}" || -z "${CA_CHAIN}" || -z "${CA_CERT}" ]]; then
    fatal "All four certificate options must be present to use a custom cert."
  fi
  while read -r CERT_FILE; do
    if ! [[ -f "${!CERT_FILE}" ]]; then
      fatal "Couldn't find file ${!CERT_FILE}."
    fi
  done <<EOF
CA_CERT
CA_ROOT
CA_KEY
CA_CHAIN
EOF

  CA_CERT="$(apath -f "${CA_CERT}")"; readonly CA_CERT;
  CA_KEY="$(apath -f "${CA_KEY}")"; readonly CA_KEY;
  CA_CHAIN="$(apath -f "${CA_CHAIN}")"; readonly CA_CHAIN;
  CA_ROOT="$(apath -f "${CA_ROOT}")"; readonly CA_ROOT;

  context_set-option "CA_CERT" "${CA_CERT}"
  context_set-option "CA_KEY" "${CA_KEY}"
  context_set-option "CA_CHAIN" "${CA_CHAIN}"
  context_set-option "CA_ROOT" "${CA_ROOT}"

  info "Checking certificate files for consistency..."
  if ! openssl rsa -in "${CA_KEY}" -check >/dev/null 2>/dev/null; then
    fatal "${CA_KEY} failed an openssl consistency check."
  fi
  if ! openssl x509 -in "${CA_CERT}" -text -noout >/dev/null; then
    fatal "${CA_CERT} failed an openssl consistency check."
  fi
  if ! openssl x509 -in "${CA_CHAIN}" -text -noout >/dev/null; then
    fatal "${CA_CHAIN} failed an openssl consistency check."
  fi
  if ! openssl x509 -in "${CA_ROOT}" -text -noout >/dev/null; then
    fatal "${CA_ROOT} failed an openssl consistency check."
  fi

  info "Checking key matches certificate..."
  local CERT_HASH; local KEY_HASH;
  CERT_HASH="$(openssl x509 -noout -modulus -in "${CA_CERT}" | openssl md5)";
  KEY_HASH="$(openssl rsa -noout -modulus -in "${CA_KEY}" | openssl md5)";
  if [[ "${CERT_HASH}" != "${KEY_HASH}" ]]; then
    fatal "Keyfile does not match the given certificate."
    fatal "Cert: ${CA_CERT}"
    fatal "Key: ${CA_KEY}"
  fi
  unset CERT_HASH; unset KEY_HASH;

  info "Verifying certificate chain of trust..."
  if ! openssl verify -trusted "${CA_ROOT}" -untrusted "${CA_CHAIN}" "${CA_CERT}"; then
    fatal "Unable to verify chain of trust."
  fi
}

configure_citadel() {
  local CUSTOM_OVERLAY; CUSTOM_OVERLAY="$(context_get-option "CUSTOM_OVERLAY")"
  CUSTOM_OVERLAY="${OPTIONS_DIRECTORY}/citadel-ca.yaml,${CUSTOM_OVERLAY}"
  context_set-option "CUSTOM_OVERLAY" "${CUSTOM_OVERLAY}"
}

install_citadel() {
  local CUSTOM_CA; CUSTOM_CA="$(context_get-option "CUSTOM_CA")"

  if [[ "${CUSTOM_CA}" -eq 1 ]]; then
    install_custom_certificates
  fi
}

install_custom_certificates() {

  local CA_CERT; CA_CERT="$(context_get-option "CA_CERT")"
  local CA_KEY; CA_KEY="$(context_get-option "CA_KEY")"
  local CA_ROOT; CA_ROOT="$(context_get-option "CA_ROOT")"
  local CA_CHAIN; CA_CHAIN="$(context_get-option "CA_CHAIN")"

  if kubectl get secret cacerts -n istio-system >/dev/null 2>/dev/null; then
    error "Custom certificates already exist in the cluster. Please remove the"
    error "'cacerts' secret from the 'istio-system' namespace and try again."
    error "If you want to keep the same custom certificates, re-run the script"
    fatal "without any of the custom certificate flags."
  fi

  info "Installing certificates into the cluster..."
  kubectl create secret generic cacerts -n istio-system \
    --from-file="${CA_CERT}" \
    --from-file="${CA_KEY}" \
    --from-file="${CA_ROOT}" \
    --from-file="${CA_CHAIN}"
}
validate_meshca() {
  return
}

configure_meshca() {
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"
  local USE_HUB_WIP; USE_HUB_WIP="$(context_get-option "USE_HUB_WIP")"
  local HUB_MEMBERSHIP_ID; HUB_MEMBERSHIP_ID="$(context_get-option "HUB_MEMBERSHIP_ID")"
  local HUB_IDP_URL; HUB_IDP_URL="$(context_get-option "HUB_IDP_URL")"

  if [[ "${USE_HUB_WIP}" -eq 1 ]]; then
    kpt cfg set asm anthos.servicemesh.idp-url "${HUB_IDP_URL}"
  else
    kpt cfg set asm anthos.servicemesh.idp-url "https://container.googleapis.com/v1/projects/${PROJECT_ID}/locations/${CLUSTER_LOCATION}/clusters/${CLUSTER_NAME}"
  fi

  configure_trust_domain_aliases
}

configure_trust_domain_aliases() {
  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local USE_HUB_WIP; USE_HUB_WIP="$(context_get-option "USE_HUB_WIP")"

  # Set the trust domain aliases to include both new Hub WIP and old Hub WIP to achieve no downtime upgrade.
  add_trust_domain_alias "${FLEET_ID}.svc.id.goog"
  add_trust_domain_alias "${FLEET_ID}.hub.id.goog"
  if [[ "${FLEET_ID}" != "${PROJECT_ID}" ]]; then
    add_trust_domain_alias "${PROJECT_ID}.svc.id.goog"
  fi
  if [[ -n "${_CI_TRUSTED_GCP_PROJECTS}" ]]; then
    # Gather the trust domain aliases from projects.
    while IFS=',' read -ra TRUSTED_GCP_PROJECT_IDS; do
      for trusted_gcp_project_id in "${TRUSTED_GCP_PROJECT_IDS[@]}"; do
        add_trust_domain_alias "${trusted_gcp_project_id}.svc.id.goog"
      done
    done <<EOF
${_CI_TRUSTED_GCP_PROJECTS}
EOF
  fi

  local ISTIOD_COUNT; ISTIOD_COUNT="$(get_istio_deployment_count)";
  # When it is the upgrade case, include the original trust domain aliases
  if [[ "$ISTIOD_COUNT" -ne 0 ]]; then
    local REVISION; REVISION="$(retry 2 kubectl -n istio-system get pod -l app=istiod \
      -o jsonpath='{.items[].spec.containers[].env[?(@.name=="REVISION")].value}')"
    local REV_NAME; REV_NAME="istio-${REVISION}"
    if [[ "${REVISION}" = default ]]; then
      REV_NAME="istio"
    fi
    local RAW_TRUST_DOMAINS_ALIASES; RAW_TRUST_DOMAINS_ALIASES="$(retry 2 kubectl -n istio-system get configmap "${REV_NAME}" \
      -o jsonpath='{.data.mesh}' | sed -e '1,/trustDomainAliases:/ d')"
    local RAW_TRUST_DOMAINS_ALIAS;
    while IFS= read -r RAW_TRUST_DOMAINS_ALIAS; do
      if [[ "$RAW_TRUST_DOMAINS_ALIAS" =~ "- " ]]; then
        add_trust_domain_alias "${RAW_TRUST_DOMAINS_ALIAS//*- }"
      else
        break
      fi
    done < <(printf '%s\n' "$RAW_TRUST_DOMAINS_ALIASES")
  fi

  # shellcheck disable=SC2046
  kpt cfg set asm anthos.servicemesh.trustDomainAliases $(context_get-option "TRUST_DOMAIN_ALIASES")
}
validate_private_ca() {
  local CA_NAME; CA_NAME="$(context_get-option "CA_NAME")"
  local CA_NAME_TEMPLATE; CA_NAME_TEMPLATE="projects/project_name/locations/ca_region/caPools/ca_pool"

  if [[ -z ${CA_NAME} ]]; then
    fatal "A ca-name must be provided for integration with Google Certificate Authority Service."
  elif [[ $(grep -o "/" <<< "${CA_NAME}" | wc -l) != $(grep -o "/" <<< "${CA_NAME_TEMPLATE}" | wc -l) ]]; then
    fatal "Malformed ca-name. ca-name must be of the form ${CA_NAME_TEMPLATE}."
  elif [[ "$(echo "${CA_NAME}" | cut -f1 -d/)" != "$(echo "${CA_NAME_TEMPLATE}" | cut -f1 -d/)" ]]; then
    fatal "Malformed ca-name. ca-name must be of the form ${CA_NAME_TEMPLATE}."
  fi
}

configure_private_ca() {
  local CA_NAME; CA_NAME="$(context_get-option "CA_NAME")"
  local CUSTOM_OVERLAY; CUSTOM_OVERLAY="$(context_get-option "CUSTOM_OVERLAY")"

  kpt cfg set asm anthos.servicemesh.external_ca.ca_name "${CA_NAME}"
  CUSTOM_OVERLAY="${OPTIONS_DIRECTORY}/private-ca.yaml,${CUSTOM_OVERLAY}"
  context_set-option "CUSTOM_OVERLAY" "${CUSTOM_OVERLAY}"

  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"
  local USE_HUB_WIP; USE_HUB_WIP="$(context_get-option "USE_HUB_WIP")"
  local HUB_MEMBERSHIP_ID; HUB_MEMBERSHIP_ID="$(context_get-option "HUB_MEMBERSHIP_ID")"
  local HUB_IDP_URL; HUB_IDP_URL="$(context_get-option "HUB_IDP_URL")"

  if [[ "${USE_HUB_WIP}" -eq 1 ]]; then
    kpt cfg set asm anthos.servicemesh.idp-url "${HUB_IDP_URL}"
  else
    kpt cfg set asm anthos.servicemesh.idp-url "https://container.googleapis.com/v1/projects/${PROJECT_ID}/locations/${CLUSTER_LOCATION}/clusters/${CLUSTER_NAME}"
  fi

  configure_trust_domain_aliases
}
validate_in_cluster_control_plane() {
  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"

  if should_validate; then
    validate_environment
  fi
  if can_init_meshconfig; then
    init_meshconfig
  elif should_validate && [[ "${FLEET_ID}" == "${PROJECT_ID}" ]]; then
    warn "There is no way to validate that the meshconfig API has been initialized."
    warn "This needs to happen once per GCP project. If the API has not been initialized"
    warn "for ${PROJECT_ID}, please re-run this tool with the --enable_gcp_components"
    warn "flag. Otherwise, installation will succeed but Anthos Service Mesh"
    warn_pause "will not function correctly."
  fi
  if can_modify_gcp_iam_roles; then
    bind_user_to_iam_policy "$(required_iam_roles)" "$(local_iam_user)"
  elif should_validate; then
    exit_if_out_of_iam_policy
  fi
}

configure_in_cluster_control_plane() {
  return
}

init_meshconfig() {
  local USE_HUB_WIP; USE_HUB_WIP="$(context_get-option "USE_HUB_WIP")"
  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"

  info "Initializing meshconfig API..."
  if [[ "${USE_HUB_WIP}" -eq 1 ]]; then
    populate_fleet_info
    local HUB_MEMBERSHIP_ID; HUB_MEMBERSHIP_ID="$(context_get-option "HUB_MEMBERSHIP_ID")"
    info "Cluster has Membership ID ${HUB_MEMBERSHIP_ID} in the Hub of project ${FLEET_ID}"
    # initialize replaces the existing Workload Identity Pools in the IAM binding, so we need to support both Hub and GKE Workload Identity Pools
    local POST_DATA
    # Initialize the Hub Hosting project with Hub WIP
    POST_DATA='{"workloadIdentityPools":["'${FLEET_ID}'.hub.id.goog","'${FLEET_ID}'.svc.id.goog"]}'
    init_meshconfig_curl "${POST_DATA}" "${FLEET_ID}"
    if [[ "${FLEET_ID}" != "${PROJECT_ID}" ]]; then
      # Initialize the cluster local project with both Hub WIP and GKE WIP
      POST_DATA='{"workloadIdentityPools":["'${FLEET_ID}'.hub.id.goog","'${FLEET_ID}'.svc.id.goog","'${PROJECT_ID}'.svc.id.goog"]}'
      init_meshconfig_curl "${POST_DATA}" "${PROJECT_ID}"
    fi
  else
    init_meshconfig_curl '' "${PROJECT_ID}"
  fi
}
validate_managed_control_plane_legacy() {
  if can_modify_gcp_iam_roles; then
    bind_user_to_iam_policy "roles/meshconfig.admin" "$(local_iam_user)"
  fi
  if can_init_meshconfig; then
    if ! init_meshconfig_managed; then
      fatal "Couldn't initialize meshconfig, do you have the required permission resourcemanager.projects.setIamPolicy?"
    fi
  fi
}

call_runIstiod() {
  local PROJECT_ID; PROJECT_ID="${1}";
  local CLUSTER_LOCATION; CLUSTER_LOCATION="${2}";
  local CLUSTER_NAME; CLUSTER_NAME="${3}";
  local POST_DATA; POST_DATA="${4}";

  check_curl --request POST \
    "https://meshconfig.googleapis.com/v1alpha1/projects/${PROJECT_ID}/locations/${CLUSTER_LOCATION}/clusters/${CLUSTER_NAME}:runIstiod" \
    --data "${POST_DATA}" \
    --header "X-Server-Timeout: 600" \
    --header "Content-Type: application/json" \
    -K <(auth_header "$(get_auth_token)")
}

install_managed_control_plane() {
  local USE_MANAGED_CNI; USE_MANAGED_CNI="$(context_get-option "USE_MANAGED_CNI")"
  local CA; CA="$(context_get-option "CA")"
  if is_legacy; then
    provision_mcp_legacy
  else
    wait_for_cpr_crd
  fi

  if [[ "${USE_MANAGED_CNI}" -eq 0 ]]; then
    install_mananged_cni_static
  fi

  if [[ "${CA}" = "gcp_cas" ]]; then
    install_managed_privateca
  fi

  install_managed_startup_config
}

provision_mcp_legacy() {
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"
  local HUB_IDP_URL; HUB_IDP_URL="$(context_get-option "HUB_IDP_URL")"

  local POST_DATA; POST_DATA="{}";
  if [[ -n "${_CI_CLOUDRUN_IMAGE_HUB}" ]]; then
    POST_DATA="$(echo "${POST_DATA}" | jq -r --arg IMAGE "${_CI_CLOUDRUN_IMAGE_HUB}:${_CI_CLOUDRUN_IMAGE_TAG}" '. + {image: $IMAGE}')"
  fi

  if [[ "${FLEET_ID}" != "${PROJECT_ID}" ]]; then
    POST_DATA="$(echo "${POST_DATA}" | jq -r --arg MEMBERSHIP "${HUB_IDP_URL/*projects/projects}" '. + {membership: $MEMBERSHIP}')"
  fi

  info "Provisioning control plane..."
  retry 2 call_runIstiod "${PROJECT_ID}" "${CLUSTER_LOCATION}" "${CLUSTER_NAME}" "${POST_DATA}"

  local MUTATING_WEBHOOK_URL
  MUTATING_WEBHOOK_URL=$(get_managed_mutating_webhook_url)

  local VALIDATION_URL
  # shellcheck disable=SC2001
  VALIDATION_URL="$(echo "${MUTATING_WEBHOOK_URL}" | sed 's/inject.*$/validate/g')"

  local CLOUDRUN_ADDR
  # shellcheck disable=SC2001
  CLOUDRUN_ADDR=$(echo "${MUTATING_WEBHOOK_URL}" | cut -d'/' -f3)

  kpt cfg set asm anthos.servicemesh.controlplane.validation-url "${VALIDATION_URL}"
  kpt cfg set asm anthos.servicemesh.managed-controlplane.cloudrun-addr "${CLOUDRUN_ADDR}"

  info "Configuring ASM managed control plane revision CRD..."
  context_append "kubectlFiles" "${CRD_CONTROL_PLANE_REVISION}"

  info "Configuring base installation for managed control plane..."
  context_append "kubectlFiles" "${BASE_REL_PATH}"

  info "Configuring ASM managed control plane validating webhook config..."
  context_append "kubectlFiles" "${MANAGED_WEBHOOKS}"
}

wait_for_cpr_crd() {
  # `kubectl wait` for non-existent resources will return error directly so we wait in loop
  info "Waiting for the controlplanerevisions CRD to be installed by AFC. This could take a few minutes if cluster is newly registered."
  for i in {1..10}; do
    if kubectl wait --for condition=established --timeout=10s crd/controlplanerevisions.mesh.cloud.google.com 2>/dev/null; then
      break
    fi
    sleep 10
  done
}

install_managed_startup_config() {
  local ASM_OPTS=""
  local MCP_CONFIG

  for MCP_CONFIG in $(context_list "mcpOptions"); do
    ASM_OPTS="${MCP_CONFIG};${ASM_OPTS}"
  done

  cat >|mcp_configmap.yaml <<EOF
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: asm-options
  namespace: istio-system
data:
  ASM_OPTS: "${ASM_OPTS}"
EOF

  context_append "kubectlFiles" "mcp_configmap.yaml"

}

install_mananged_cni_static() {
  info "Configuring CNI..."
  local ASM_OPTS
  ASM_OPTS="$(kubectl -n istio-system \
    get --ignore-not-found cm asm-options \
    -o jsonpath='{.data.ASM_OPTS}' || true)"

  if [[ -z "${ASM_OPTS}" || "${ASM_OPTS}" != *"CNI=on"* ]]; then
    context_append "mcpOptions" "CNI=on"
  fi
  context_append "kubectlFiles" "${MANAGED_CNI}"
}

install_managed_privateca() {
  info "Configuring GCP CAS with managed control plane..."

  local CA_NAME; CA_NAME="$(context_get-option "CA_NAME")"
  context_append "mcpOptions" "CA=PRIVATECA"
  context_append "mcpOptions" "CAAddr=${CA_NAME}"
}

configure_managed_control_plane() {
  :
}

get_managed_mutating_webhook_url() {
  # Get the url for the most up to date channel that the cluster is using.
  local WEBHOOKS; WEBHOOKS="istiod-asm-managed-rapid istiod-asm-managed istiod-asm-managed-stable"
  local WEBHOOK_JSON

  for WEBHOOK in $WEBHOOKS; do
    if WEBHOOK_JSON="$(kubectl get mutatingwebhookconfiguration "${WEBHOOK}" -ojson)" ; then
      info "Using the following managed revision for validating webhook: ${WEBHOOK#'istiod-'}"
      echo "$WEBHOOK_JSON" | jq .webhooks[0].clientConfig.url -r
      return
    fi
  done

  fatal "Could not find managed config map."
}


init_meshconfig_managed() {
  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"

  info "Initializing meshconfig managed API..."
  local POST_DATA
  # When cluster local project is the same as the Hub Hosting Project
  # Initialize the project with Hub WIP and prepare istiod
  if [[ "${FLEET_ID}" == "${PROJECT_ID}" ]]; then
    POST_DATA='{"workloadIdentityPools":["'${FLEET_ID}'.hub.id.goog","'${FLEET_ID}'.svc.id.goog"], "prepare_istiod": true}'
    init_meshconfig_curl "${POST_DATA}" "${FLEET_ID}"
  # When cluster local project is different from the Hub Hosting Project
  # Initialize the Hub Hosting project with Hub WIP
  # Initialize the cluster local project with Hub WIP & GKE WIP and prepare istiod
  else
    POST_DATA='{"workloadIdentityPools":["'${FLEET_ID}'.hub.id.goog","'${FLEET_ID}'.svc.id.goog"]}'
    init_meshconfig_curl "${POST_DATA}" "${FLEET_ID}"
    POST_DATA='{"workloadIdentityPools":["'${FLEET_ID}'.hub.id.goog","'${FLEET_ID}'.svc.id.goog","'${PROJECT_ID}'.svc.id.goog"], "prepare_istiod": true}'
    init_meshconfig_curl "${POST_DATA}" "${PROJECT_ID}"
  fi
}
has_value() {
  local VALUE; VALUE="$(context_get-option "${1}")"

  if [[ -n "${VALUE}" ]]; then return; fi

  if is_interactive; then
    VALUE="$(prompt_user_for_value "${1}")"
    echo "$VALUE"
  fi

  if [[ -n "${VALUE}" ]]; then
    context_set-option "${1}" "${VALUE}"
    return
  fi
  false
}

not_null() {
  local VALUE; VALUE="$1";
  [[ -n "${VALUE}" && "${VALUE}" != "null" ]]
}

is_managed() {
  local MANAGED; MANAGED="$(context_get-option "MANAGED")"

  if [[ "${MANAGED}" -ne 1 ]]; then false; fi
}

is_legacy() {
  local LEGACY; LEGACY="$(context_get-option "LEGACY")"

  if [[ "${LEGACY}" -ne 1 ]]; then false; fi
}

is_interactive() {
  local NON_INTERACTIVE; NON_INTERACTIVE="$(context_get-option "NON_INTERACTIVE")"

  if [[ "${NON_INTERACTIVE}" -eq 1 ]]; then false; fi
}

is_gcp() {
  local PLATFORM; PLATFORM="$(context_get-option "PLATFORM")"
  if [[ "${PLATFORM}" == "gcp" ]]; then
    true
  else
    false
  fi
}

using_connect_gateway() {
  local KVC; KVC="$(context_get-option "KC_VIA_CONNECT")"
  if [[ "${KVC}" -eq 1 ]]; then
    true
  else
    false
  fi
}

is_sa() {
  local SERVICE_ACCOUNT; SERVICE_ACCOUNT="$(context_get-option "SERVICE_ACCOUNT")"

  if [[ -z "${SERVICE_ACCOUNT}" ]]; then false; fi
}

is_sa_impersonation() {
  local IMPERSONATE_USER; IMPERSONATE_USER="$(gcloud config get-value auth/impersonate_service_account)"
  if [[ -z "${IMPERSONATE_USER}" ]]; then false; fi
}

is_meshca_installed() {
  local INSTALLED_CA; INSTALLED_CA="$(kubectl -n istio-system get pod -l istio=ingressgateway \
    -o jsonpath='{.items[].spec.containers[].env[?(@.name=="CA_ADDR")].value}')"
  [[ "${INSTALLED_CA}" =~ meshca\.googleapis\.com ]] && return 0
}

is_gcp_cas_installed() {
  local INSTALLED_CA_PROVIDER
  INSTALLED_CA_PROVIDER="$(kubectl -n istio-system get pod -l istio=ingressgateway \
    -o jsonpath='{.items[].spec.containers[].env[?(@.name=="CA_PROVIDER")].value}')"
  [[ "${INSTALLED_CA_PROVIDER}" = "GoogleCAS" ]] && return 0
}

is_cluster_registered() {
  info "Verifying cluster registration."

  if ! is_membership_crd_installed; then
    false
    return
  fi

  local MEMBERSHIP_DATA IDENTITY_PROVIDER
  MEMBERSHIP_DATA="$(retry 2 kubectl get memberships.hub.gke.io membership -ojson 2>/dev/null)"

  # expected value is the project id to which the cluster is registered
  IDENTITY_PROVIDER="$(echo "${MEMBERSHIP_DATA}" \
    | jq .spec.identity_provider \
    | sed -E 's/.*projects\/|\/locations.*//g')"
  if [[ -z "${IDENTITY_PROVIDER}" || "${IDENTITY_PROVIDER}" == 'null' ]]; then
    { read -r -d '' MSG; fatal "${MSG}"; } <<EOF || true
Cluster has memberships.hub.gke.io CRD but no identity provider specified.
Please ensure that the registered cluster has fleet workload identity enabled:
https://cloud.google.com/anthos/multicluster-management/fleets/workload-identity
EOF
  fi

  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"

  populate_fleet_info
  local MEMBERSHIP LOCATION WANT LIST G_DATA
  LOCATION="$(echo "${MEMBERSHIP_DATA}" \
    | jq -r .spec.owner.id \
    | sed -E 's/.*locations\/|\/memberships.*//g')"
  MEMBERSHIP="$(echo "${MEMBERSHIP_DATA}" \
    | jq -r .spec.owner.id \
    | sed -E 's/.*memberships\///g')"
  WANT="name.*projects/${FLEET_ID}/locations/${LOCATION}/memberships/${MEMBERSHIP}"
  G_DATA="$(gcloud container hub memberships list --project "${FLEET_ID}" --format=json)"
  LIST="$(echo "${G_DATA}" | grep "${WANT}")"

  if [[ "${IDENTITY_PROVIDER}" != "${FLEET_ID}" ]] || \
     [[ -z "${LIST}" ]]; then
    { read -r -d '' MSG; fatal "${MSG}"; } <<EOF || true
Cluster is registered in the project ${IDENTITY_PROVIDER}, but the required Fleet project is ${FLEET_ID}.
Please ensure that the cluster is registered to the ${FLEET_ID} project.
EOF
  fi

  if using_connect_gateway && is_gcp; then
    local ENDPOINT C_PROJ C_LOC C_NAME
    ENDPOINT="$(echo "${G_DATA}" | \
      jq -r '.[] | select(.name=="'"${WANT#??????}"'") | .endpoint.gkeCluster.resourceLink')"

    read -r C_PROJ C_LOC C_NAME <<EOF
$(echo "${ENDPOINT}" | sed 's/\/\/container.googleapis.com\/projects\/\(.*\)\/locations\/\(.*\)\/clusters\/\(.*\)$/\1 \2 \3/g')
EOF

    context_set-option "PROJECT_ID" "${C_PROJ}"
    context_set-option "CLUSTER_LOCATION" "${C_LOC}"
    context_set-option "CLUSTER_NAME" "${C_NAME}"
  fi

  info "Verified cluster is registered to ${IDENTITY_PROVIDER}"
}

is_workload_identity_enabled() {
  local WI_ENABLED; WI_ENABLED="$(context_get-option "WI_ENABLED")"
  if [[ "${WI_ENABLED}" -eq 1 ]]; then return; fi

  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"

  local ENABLED
  ENABLED="$(gcloud container clusters describe \
    --project="${PROJECT_ID}" \
    --region "${CLUSTER_LOCATION}" \
    "${CLUSTER_NAME}" \
    --format=json | \
    jq .workloadIdentityConfig)"

  if [[ "${ENABLED}" = 'null' ]]; then
    false;
  else
    WI_ENABLED=1;
    context_set-option "WI_ENABLED" "${WI_ENABLED}"
  fi
}

is_membership_crd_installed() {
  local OUTPUT
  if ! OUTPUT="$(retry 2 kubectl get crd memberships.hub.gke.io -ojsonpath="{..metadata.name}" 2>/dev/null)"; then
    false
    return
  fi

  if [[ "$(echo "${OUTPUT}" | grep -w -c memberships || true)" -eq 0 ]]; then
    false
    return
  fi

  if ! OUTPUT="$(retry 2 kubectl get memberships.hub.gke.io -ojsonpath="{..metadata.name}" 2>/dev/null)"; then
    false
    return
  fi

  if [[ "$(echo "${OUTPUT}" | grep -w -c membership || true)" -eq 0 ]]; then
    false
    return
  fi
}

is_stackdriver_enabled() {
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"

  local ENABLED
  ENABLED="$(gcloud container clusters describe \
    --project="${PROJECT_ID}" \
    --region "${CLUSTER_LOCATION}" \
    "${CLUSTER_NAME}" \
    --format=json | \
    jq '.
    | [
    select(
      .loggingService == "logging.googleapis.com/kubernetes"
      and .monitoringService == "monitoring.googleapis.com/kubernetes")
      ] | length')"

  if [[ "${ENABLED}" -lt 1 ]]; then false; fi
}

is_user_cluster_admin() {
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local GCLOUD_USER; GCLOUD_USER="$(gcloud config get-value core/account)"
  local IAM_USER; IAM_USER="$(local_iam_user)"
  local ROLES
  ROLES="$(\
    kubectl get clusterrolebinding \
    --all-namespaces \
    -o jsonpath='{range .items[?(@.subjects[0].name=="'"${GCLOUD_USER}"'")]}[{.roleRef.name}]{end}'\
    2>/dev/null)"
  if echo "${ROLES}" | grep -q cluster-admin; then return; fi

  ROLES="$(gcloud projects \
    get-iam-policy "${PROJECT_ID}" \
    --flatten='bindings[].members' \
    --filter="bindings.members:${IAM_USER}" \
    --format='value(bindings.role)' 2>/dev/null)"
  if echo "${ROLES}" | grep -q roles/container.admin; then return; fi

  false
}

is_service_mesh_feature_enabled() {
  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"

  local RESPONSE
  RESPONSE="$(run_command gcloud beta container hub mesh describe --project="${FLEET_ID}")"

  if [[ "$(echo "${RESPONSE}" | jq -r '.featureState.lifecycleState')" != "ENABLED" ]]; then
    false
  fi
}

should_validate() {
  local PRINT_CONFIG; PRINT_CONFIG="$(context_get-option "PRINT_CONFIG")"

  if [[ "${PRINT_CONFIG}" -eq 1 || "${_CI_NO_VALIDATE}" -eq 1 ]] || only_enable; then false; fi
}

only_validate() {
  local ONLY_VALIDATE; ONLY_VALIDATE="$(context_get-option "ONLY_VALIDATE")"
  if [[ "${ONLY_VALIDATE}" -eq 0 ]]; then false; fi
}

only_enable() {
  local ONLY_ENABLE; ONLY_ENABLE="$(context_get-option "ONLY_ENABLE")"
  if [[ "${ONLY_ENABLE}" -eq 0 ]]; then false; fi
}

can_modify_at_all() {
  local ONLY_VALIDATE; ONLY_VALIDATE="$(context_get-option "ONLY_VALIDATE")"
  local PRINT_CONFIG; PRINT_CONFIG="$(context_get-option "PRINT_CONFIG")"

  if [[ "${ONLY_VALIDATE}" -eq 1 || "${PRINT_CONFIG}" -eq 1 ]]; then false; fi
}

can_modify_cluster_roles() {
  local ENABLE_ALL; ENABLE_ALL="$(context_get-option "ENABLE_ALL")"
  local ENABLE_CLUSTER_ROLES; ENABLE_CLUSTER_ROLES="$(context_get-option "ENABLE_CLUSTER_ROLES")"

  if ! can_modify_at_all; then false; return; fi

  if is_managed || [[ "${ENABLE_ALL}" -eq 1 || "${ENABLE_CLUSTER_ROLES}" -eq 1 ]]; then
    true
  else
    false
  fi
}

can_modify_cluster_labels() {
  local ENABLE_ALL; ENABLE_ALL="$(context_get-option "ENABLE_ALL")"
  local ENABLE_CLUSTER_LABELS; ENABLE_CLUSTER_LABELS="$(context_get-option "ENABLE_CLUSTER_LABELS")"

  if ! can_modify_at_all; then false; return; fi

  if [[ "${ENABLE_ALL}" -eq 1 || "${ENABLE_CLUSTER_LABELS}" -eq 1 ]]; then
    true
  else
    false
  fi
}

can_modify_gcp_apis() {
  local ENABLE_ALL; ENABLE_ALL="$(context_get-option "ENABLE_ALL")"
  local ENABLE_GCP_APIS; ENABLE_GCP_APIS="$(context_get-option "ENABLE_GCP_APIS")"

  if ! can_modify_at_all; then false; return; fi

  if [[ "${ENABLE_ALL}" -eq 1 || "${ENABLE_GCP_APIS}" -eq 1 ]]; then
    true
  else
    false
  fi
}

can_modify_gcp_iam_roles() {
  local ENABLE_ALL; ENABLE_ALL="$(context_get-option "ENABLE_ALL")"
  local ENABLE_GCP_IAM_ROLES; ENABLE_GCP_IAM_ROLES="$(context_get-option "ENABLE_GCP_IAM_ROLES")"

  if ! can_modify_at_all; then false; return; fi

  if is_managed || [[ "${ENABLE_ALL}" -eq 1 || "${ENABLE_GCP_IAM_ROLES}" -eq 1 ]]; then
    true
  else
    false
  fi
}

can_modify_gcp_components() {
  local ENABLE_ALL; ENABLE_ALL="$(context_get-option "ENABLE_ALL")"
  local ENABLE_GCP_COMPONENTS; ENABLE_GCP_COMPONENTS="$(context_get-option "ENABLE_GCP_COMPONENTS")"

  if ! can_modify_at_all; then false; return; fi

  if is_managed || [[ "${ENABLE_ALL}" -eq 1 || "${ENABLE_GCP_COMPONENTS}" -eq 1 ]]; then
    true
  else
    false
  fi
}

can_init_meshconfig() {
  local ENABLE_ALL; ENABLE_ALL="$(context_get-option "ENABLE_ALL")"
  local ENABLE_MESHCONFIG_INIT; ENABLE_MESHCONFIG_INIT="$(context_get-option "ENABLE_MESHCONFIG_INIT")"

  if ! can_modify_at_all; then false; return; fi
  if can_modify_gcp_components; then return; fi

  if is_managed || [[ "${ENABLE_ALL}" -eq 1 || "${ENABLE_MESHCONFIG_INIT}" -eq 1 ]]; then
    true
  else
    false
  fi
}

can_register_cluster() {
  local ENABLE_ALL; ENABLE_ALL="$(context_get-option "ENABLE_ALL")"
  local USE_VM; USE_VM="$(context_get-option "USE_VM")"
  local USE_HUB_WIP; USE_HUB_WIP="$(context_get-option "USE_HUB_WIP")"
  local ENABLE_REGISTRATION; ENABLE_REGISTRATION="$(context_get-option "ENABLE_REGISTRATION")"

  if ! can_modify_at_all; then false; return; fi

  if [[ "${ENABLE_ALL}" -eq 1 || "${USE_VM}" -eq 1 || "${ENABLE_REGISTRATION}" -eq 1 ]]; then
    true
  else
    false
  fi
}

can_create_namespace() {
  local ENABLE_ALL; ENABLE_ALL="$(context_get-option "ENABLE_ALL")"
  local ENABLE_NAMESPACE_CREATION; ENABLE_NAMESPACE_CREATION="$(context_get-option "ENABLE_NAMESPACE_CREATION")"

  if ! can_modify_at_all; then false; return; fi

  if [[ "${ENABLE_ALL}" -eq 1 || "${ENABLE_NAMESPACE_CREATION}" -eq 1 ]]; then
    true
  else
    false
  fi
}

needs_kpt() {
  if [[ -z "${AKPT}" ]]; then return; fi
  local KPT_VER
  KPT_VER="$(kpt version)"
  if [[ "${KPT_VER:0:1}" != "0" ]]; then return; fi
  false
}

needs_asm() {
  local PRINT_CONFIG; PRINT_CONFIG="$(context_get-option "PRINT_CONFIG")"

  if only_enable; then false; return; fi

  if [[ "${PRINT_CONFIG}" -eq 1 ]] || can_modify_at_all || should_validate; then
    true
  else
    false
  fi
}

needs_service_mesh_feature() {
  local USE_VM; USE_VM="$(context_get-option "USE_VM")"

  if is_managed || [[ "${USE_VM}" -eq 1 ]]; then
    true
  else
    false
  fi
}

version_valid_for_upgrade() {
  local VERSION; VERSION=$1

  # if asm version found, pattern: 1.6.11-asm.1-586f900508ad482ed32b830dd15f6c54b32b93ed
  local VERSION_MAJOR VERSION_MINOR VERSION_POINT VERSION_REV
  IFS="." read -r VERSION_MAJOR VERSION_MINOR VERSION_POINT VERSION_REV <<EOF
${VERSION}
EOF
  VERSION_POINT="$(sed 's/-.*//' <<EOF
${VERSION_POINT}
EOF
)"
  VERSION_REV="$(sed 's/-.*//' <<EOF
${VERSION_REV}
EOF
)"
  if is_major_minor_invalid || is_minor_point_rev_invalid; then
    false
  fi
}

is_major_minor_invalid() {
  [[ "$VERSION_MAJOR" -ne 1 ]] && return 0
  [[ "$VERSION_MINOR" -lt $((MINOR-1))  ]] && return 0
  [[ "$VERSION_MINOR" -gt "$MINOR" ]] && return 0
}

is_minor_point_rev_invalid() {
  [[ "$VERSION_MINOR" -eq "$MINOR" ]] && is_point_rev_invalid && return 0
}

is_point_rev_invalid() {
  [[ "$VERSION_POINT" -gt "$POINT" ]] && return 0
  is_rev_invalid && return 0
}

is_rev_invalid() {
  [[ "$VERSION_POINT" -eq "$POINT" && "$VERSION_REV" -ge "$REV" ]] && return 0
}

istio_namespace_exists() {
  if [[ "${NAMESPACE_EXISTS}" -eq 1 ]]; then return; fi
  if [[ "$(retry 2 kubectl get ns | grep -c istio-system || true)" -eq 0 ]]; then
    false
  else
    NAMESPACE_EXISTS=1; readonly NAMESPACE_EXISTS
  fi
}
configure_package() {
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"
  local USE_HUB_WIP; USE_HUB_WIP="$(context_get-option "USE_HUB_WIP")"
  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"
  local HUB_MEMBERSHIP_ID; HUB_MEMBERSHIP_ID="$(context_get-option "HUB_MEMBERSHIP_ID")"
  local CA; CA="$(context_get-option "CA")"
  local CA_NAME; CA_NAME="$(context_get-option "CA_NAME")"
  local USE_VM; USE_VM="$(context_get-option "USE_VM")"
  local HUB_IDP_URL; HUB_IDP_URL="$(context_get-option "HUB_IDP_URL")"
  local USE_MANAGED_CNI; USE_MANAGED_CNI="$(context_get-option "USE_MANAGED_CNI")"
  local USE_VPCSC; USE_VPCSC="$(context_get-option "USE_VPCSC")"

  info "Configuring kpt package..."

  populate_cluster_values
  local NETWORK_ID; NETWORK_ID="$(context_get-option "NETWORK_ID")"

  populate_fleet_info

  if is_gcp; then
    kpt cfg set asm gcloud.container.cluster "${CLUSTER_NAME}"
    kpt cfg set asm gcloud.core.project "${PROJECT_ID}"
    kpt cfg set asm gcloud.compute.location "${CLUSTER_LOCATION}"
  else
    kpt cfg set asm gcloud.core.project "${FLEET_ID}"
    if [[ -n "${HUB_MEMBERSHIP_ID}" ]]; then
      kpt cfg set asm gcloud.container.cluster "${HUB_MEMBERSHIP_ID}"
    else
      kpt cfg set asm gcloud.container.cluster "cluster" # default off-GCP cluster name
    fi
    # "global" is the current default value for off-GCP
    kpt cfg set asm gcloud.compute.location "global"
    if [[ "${CA}" == "citadel" ]]; then
      kpt cfg set asm anthos.servicemesh.controlplane.monitoring.enabled "false"
    fi
  fi

  kpt cfg set asm gcloud.compute.network "${NETWORK_ID}"
  kpt cfg set asm gcloud.project.environProjectNumber "${PROJECT_NUMBER}"
  kpt cfg set asm anthos.servicemesh.rev "${REVISION_LABEL}"
  kpt cfg set asm anthos.servicemesh.tag "${RELEASE}"
  if [[ -n "${_CI_ASM_IMAGE_LOCATION}" ]]; then
    kpt cfg set asm anthos.servicemesh.hub "${_CI_ASM_IMAGE_LOCATION}"
  fi
  if [[ -n "${_CI_ASM_IMAGE_TAG}" ]]; then
    kpt cfg set asm anthos.servicemesh.tag "${_CI_ASM_IMAGE_TAG}"
  fi

  if [[ -n "${CA_NAME}" && "${CA}" = "gcp_cas" ]]; then
    kpt cfg set asm anthos.servicemesh.external_ca.ca_name "${CA_NAME}"
  fi

  kpt cfg set asm anthos.servicemesh.trustDomain "${FLEET_ID}.svc.id.goog"
  kpt cfg set asm anthos.servicemesh.tokenAudiences "istio-ca,${FLEET_ID}.svc.id.goog"
  if [[ "${CA}" == "mesh_ca" ]]; then
    kpt cfg set asm anthos.servicemesh.spiffeBundleEndpoints "${FLEET_ID}.svc.id.goog|https://storage.googleapis.com/mesh-ca-resources/spiffe_bundle.json"
  fi

  if [[ "${USE_VM}" -eq 1 ]] && [[ "${_CI_NO_REVISION}" -eq 0 ]]; then
    kpt cfg set asm anthos.servicemesh.istiodHost "istiod-${REVISION_LABEL}.istio-system.svc"
    kpt cfg set asm anthos.servicemesh.istiodHostFQDN "istiod-${REVISION_LABEL}.istio-system.svc.cluster.local"
    kpt cfg set asm anthos.servicemesh.istiod-vs-name "istiod-vs-${REVISION_LABEL}"
  fi
  
  if [[ "${USE_MANAGED_CNI}" -eq 1 ]]; then
    kpt cfg set asm anthos.servicemesh.use-managed-cni "true"
  fi
  if [[ "${USE_VPCSC}" -eq 1 ]]; then
    kpt cfg set asm anthos.servicemesh.managed-controlplane.vpcsc.enabled "true"
  fi

  configure_ca
  configure_control_plane
}

configure_kubectl(){
  local CONTEXT; CONTEXT="$(context_get-option "CONTEXT")"
  local KUBECONFIG; KUBECONFIG="$(context_get-option "KUBECONFIG")"
  local KUBECONFIG_SUPPLIED; KUBECONFIG_SUPPLIED="$(context_get-option "KUBECONFIG_SUPPLIED")"

  if [[ "${KUBECONFIG_SUPPLIED}" -eq 0 ]]; then
    local PROJECT_ID; PROJECT_ID="${1}"
    local CLUSTER_LOCATION; CLUSTER_LOCATION="${2}"
    local CLUSTER_NAME; CLUSTER_NAME="${3}"

    info "Fetching/writing GCP credentials to kubeconfig file..."
    KUBECONFIG="${KUBECONFIG}" retry 2 gcloud container clusters get-credentials "${CLUSTER_NAME}" \
      --project="${PROJECT_ID}" \
      --zone="${CLUSTER_LOCATION}"
    context_set-option "KUBECONFIG" "${KUBECONFIG}"
    context_set-option "CONTEXT" "$(kubectl config current-context)"
  fi

  if ! hash nc 2>/dev/null; then
     warn "nc not found, skipping k8s connection verification"
     warn "(Installation will continue normally.)"
     return
  fi

  if is_gcp; then
    verify_connectivity
  fi

  info "kubeconfig set to ${KUBECONFIG}"
  CONTEXT="$(context_get-option "CONTEXT")"
  info "using context ${CONTEXT}"
}
context_init() {
  local CONTEXT_JSON; CONTEXT_JSON=$(cat <<EOF
{
  "flags": {
    "PROJECT_ID": "${PROJECT_ID:-}",
    "CLUSTER_NAME": "${CLUSTER_NAME:-}",
    "CLUSTER_LOCATION": "${CLUSTER_LOCATION:-}",
    "GKE_CLUSTER_URI": "${GKE_CLUSTER_URI:-}",
    "KUBECONFIG": "${KUBECONFIG_FILE:-}",
    "KUBECONFIG_SUPPLIED": "${KUBECONFIG_SUPPLIED:-0}",
    "FLEET_ID": "${FLEET_ID:-}",
    "CA": "${CA:-}",
    "PLATFORM": "${PLATFORM:-}",
    "CONTEXT": "${CONTEXT:-}",
    "CUSTOM_OVERLAY": "${CUSTOM_OVERLAY:-}",
    "OPTIONAL_OVERLAY": "${OPTIONAL_OVERLAY:-}",
    "NETWORK_ID": "${NETWORK_ID:-}",
    "ENABLE_ALL": ${ENABLE_ALL:-0},
    "ENABLE_CLUSTER_ROLES": ${ENABLE_CLUSTER_ROLES:-0},
    "ENABLE_CLUSTER_LABELS": ${ENABLE_CLUSTER_LABELS:-0},
    "ENABLE_GCP_APIS": ${ENABLE_GCP_APIS:-0},
    "ENABLE_GCP_IAM_ROLES": ${ENABLE_GCP_IAM_ROLES:-0},
    "ENABLE_GCP_COMPONENTS": ${ENABLE_GCP_COMPONENTS:-0},
    "ENABLE_REGISTRATION": ${ENABLE_REGISTRATION:-0},
    "ENABLE_NAMESPACE_CREATION": ${ENABLE_NAMESPACE_CREATION:-0},
    "ENABLE_MESHCONFIG_INIT": ${ENABLE_MESHCONFIG_INIT:-0},
    "USE_MANAGED_CNI": ${USE_MANAGED_CNI:-0},
    "USE_VPCSC": ${USE_VPCSC:-0},
    "DISABLE_CANONICAL_SERVICE": ${DISABLE_CANONICAL_SERVICE:-0},
    "TRUST_FLEET_IDENTITY": ${TRUST_FLEET_IDENTITY:-1},
    "PRINT_CONFIG": ${PRINT_CONFIG:-0},
    "NON_INTERACTIVE": ${NON_INTERACTIVE:-0},
    "SERVICE_ACCOUNT": "${SERVICE_ACCOUNT:-}",
    "KEY_FILE": "${KEY_FILE:-}",
    "OUTPUT_DIR": "${OUTPUT_DIR:-}",
    "CA_CERT": "${CA_CERT:-}",
    "CA_KEY": "${CA_KEY:-}",
    "CA_ROOT": "${CA_ROOT:-}",
    "CA_CHAIN": "${CA_CHAIN:-}",
    "CA_NAME": "${CA_NAME:-}",
    "DRY_RUN": ${DRY_RUN:-0},
    "ONLY_VALIDATE": ${ONLY_VALIDATE:-0},
    "VALIDATION_ERROR": ${VALIDATION_ERROR:-0},
    "ONLY_ENABLE": ${ONLY_ENABLE:-0},
    "VERBOSE": ${VERBOSE:-0},
    "MANAGED": ${MANAGED:-0},
    "LEGACY": ${LEGACY:-0},
    "MANAGED_SERVICE_ACCOUNT": "${MANAGED_SERVICE_ACCOUNT:-}",
    "PRINT_HELP": ${PRINT_HELP:-0},
    "PRINT_VERSION": ${PRINT_VERSION:-0},
    "CUSTOM_CA": ${CUSTOM_CA:-0},
    "USE_HUB_WIP": ${USE_HUB_WIP:-1},
    "USE_VM": ${USE_VM:-0},
    "HUB_MEMBERSHIP_ID": "${HUB_MEMBERSHIP_ID:-}",
    "CUSTOM_REVISION": ${CUSTOM_REVISION:-0},
    "TRUST_DOMAIN_ALIASES": "${TRUST_DOMAIN_ALIASES:-}",
    "WI_ENABLED": ${WI_ENABLED:-0},
    "HTTPS_PROXY": "${HTTPS_PROXY:-}",
    "INSTALL_EXPANSION_GATEWAY": ${INSTALL_EXPANSION_GATEWAY:-0},
    "INSTALL_IDENTITY_PROVIDER": ${INSTALL_IDENTITY_PROVIDER:-0},
    "EXPERIMENTAL": ${EXPERIMENTAL:-0},
    "KC_VIA_CONNECT": ${KC_VIA_CONNECT:-0},
    "CHANNEL": "${CHANNEL:-}"
  },
  "istioctlFiles": [],
  "kubectlFiles": [],
  "mcpOptions": [],
  "clustersInfo": [],
  "clusterRegistrations": [],
  "clusterContexts": [],
  "kubeconfigFiles": []
}
EOF
)

  context_FILE_LOCATION="$(mktemp)"; readonly context_FILE_LOCATION
  export context_FILE_LOCATION

  echo "${CONTEXT_JSON}" | jq -S '.' >| "${context_FILE_LOCATION}"

  context_post-init
}

# Function to be called at the end of context_init
# that houses any secondary initialization or cleanup
# steps after the context has been initialized.
context_post-init() {

  # Certain multicloud clusters require kubectl to use
  # a proxy. If this proxy is exported, the gcloud will
  # break.
  unset HTTPS_PROXY
}

context_get-option() {
  local OPTION; OPTION="${1}"

  jq -r --arg OPTION "${OPTION}" '.flags[$OPTION]' "${context_FILE_LOCATION}"
}

context_set-option() {
  local OPTION; OPTION="${1}"
  local VALUE; VALUE="${2}"
  local TEMP_FILE; TEMP_FILE="$(mktemp)"

  jq -S --arg OPTION "${OPTION}" --arg VALUE "${VALUE}" \
  '.flags[$OPTION]=($VALUE | try tonumber catch $VALUE)' "${context_FILE_LOCATION}" >| "${TEMP_FILE}" \
  && mv "${TEMP_FILE}" "${context_FILE_LOCATION}"
}

context_append() {
  local KEY; KEY="${1}"
  local VALUE; VALUE="${2}"
  local TEMP_FILE; TEMP_FILE="$(mktemp)"

  jq -S --arg KEY "${KEY}" --arg VALUE "${VALUE}" '.[$KEY] += [$VALUE]' "${context_FILE_LOCATION}" >| "${TEMP_FILE}" \
  && mv "${TEMP_FILE}" "${context_FILE_LOCATION}"
}

context_list() {
  local KEY; KEY="${1}"
  jq -S -r --arg KEY "${KEY}" '.[$KEY][]' "${context_FILE_LOCATION}"
}
required_iam_roles_mcp_sa() {
  cat <<EOF
roles/serviceusage.serviceUsageConsumer
roles/container.admin
roles/monitoring.metricWriter
roles/logging.logWriter
EOF
}

# [START required_iam_roles]
required_iam_roles() {
  # meshconfig.admin - required for init, stackdriver, UI elements, etc.
  # servicemanagement.admin/serviceusage.serviceUsageAdmin - enables APIs
  local CA; CA="$(context_get-option "CA")"
  if is_gcp && { can_modify_gcp_components || \
     can_modify_cluster_labels || \
     can_modify_cluster_roles; }; then
    echo roles/container.admin
  fi
  if can_modify_gcp_components; then
    echo roles/meshconfig.admin
  fi
  if can_modify_gcp_apis; then
    echo roles/servicemanagement.admin
    echo roles/serviceusage.serviceUsageAdmin
  fi
  if can_modify_gcp_iam_roles; then
    echo roles/resourcemanager.projectIamAdmin
  fi
  if is_sa; then
    echo roles/iam.serviceAccountAdmin
  fi
  if can_register_cluster; then
    echo roles/gkehub.admin
  fi
  if [[ "${CA}" = "gcp_cas" ]]; then
    echo roles/privateca.admin
  fi
  if [[ "${_CI_I_AM_A_TEST_ROBOT}" -eq 1 ]]; then
    echo roles/compute.admin
    echo roles/iam.serviceAccountKeyAdmin
  fi
}
# [END required_iam_roles]

# [START required_apis]
required_apis() {
  local CA; CA="$(context_get-option "CA")"
    cat << EOF
container.googleapis.com
monitoring.googleapis.com
logging.googleapis.com
cloudtrace.googleapis.com
meshconfig.googleapis.com
iamcredentials.googleapis.com
gkeconnect.googleapis.com
gkehub.googleapis.com
cloudresourcemanager.googleapis.com
stackdriver.googleapis.com
EOF
  case "${CA}" in
   mesh_ca)
     echo meshca.googleapis.com
     ;;
   gcp_cas)
     echo privateca.googleapis.com
     ;;
    *);;
  esac

  if [[ "${_CI_I_AM_A_TEST_ROBOT}" -eq 1 ]]; then
    echo compute.googleapis.com
  fi
}
# [END required_apis]

required_fleet_apis() {
  local CA; CA="$(context_get-option "CA")"
  case "${CA}" in
   mesh_ca)
     echo meshca.googleapis.com
     ;;
   gcp_cas)
     echo privateca.googleapis.com
     ;;
    *);;
  esac
}

bind_user_to_cluster_admin(){
  info "Querying for core/account..."
  local GCLOUD_USER; GCLOUD_USER="$(gcloud config get-value core/account)"
  info "Binding ${GCLOUD_USER} to cluster admin role..."
  local PREFIX; PREFIX="$(echo "${GCLOUD_USER}" | cut -f 1 -d @)"
  local YAML; YAML="$(retry 5 kubectl create \
    clusterrolebinding "${PREFIX}-cluster-admin-binding" \
    --clusterrole=cluster-admin \
    --user="${GCLOUD_USER}" \
    --dry-run -o yaml)"
  retry 3 kubectl apply -f - <<EOF
${YAML}
EOF
}

local_iam_user() {
  if [[ -n "${GCLOUD_USER_OR_SA}" ]]; then
    echo "${GCLOUD_USER_OR_SA}"
    return
  fi

  info "Getting account information..."
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local ACCOUNT_NAME
  ACCOUNT_NAME="$(retry 3 gcloud auth list \
    --project="${PROJECT_ID}" \
    --filter="status:ACTIVE" \
    --format="value(account)")"
  if [[ -z "${ACCOUNT_NAME}" ]]; then
    fatal "Failed to get account name from gcloud. Please authorize and re-try installation."
  fi

  local ACCOUNT_TYPE
  ACCOUNT_TYPE="user"
  if is_sa || [[ "${ACCOUNT_NAME}" = *.gserviceaccount.com ]]; then
    ACCOUNT_TYPE="serviceAccount"
  fi

  if is_sa_impersonation; then
    ACCOUNT_NAME="$(gcloud config get-value auth/impersonate_service_account)"
    ACCOUNT_TYPE="serviceAccount"
    warn "Service account impersonation currently configured to impersonate '${ACCOUNT_NAME}'."
  fi

  GCLOUD_USER_OR_SA="${ACCOUNT_TYPE}:${ACCOUNT_NAME}"
  readonly GCLOUD_USER_OR_SA
  echo "${GCLOUD_USER_OR_SA}"
}

bind_user_to_iam_policy(){
  local ROLES; ROLES="${1}"
  local GCLOUD_MEMBER; GCLOUD_MEMBER="${2}"
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"

  info "Binding ${GCLOUD_MEMBER} to required IAM roles..."
  while read -r role; do
  retry 3 gcloud projects add-iam-policy-binding "${PROJECT_ID}" \
    --member "${GCLOUD_MEMBER}" \
    --role="${role}" --condition=None >/dev/null
  done <<EOF
${ROLES}
EOF
}

enable_gcloud_apis(){
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"

  info "Enabling required APIs..."
  # shellcheck disable=SC2046
  retry 3 gcloud services enable --project="${PROJECT_ID}" $(required_apis | tr '\n' ' ')

  if [[ "${FLEET_ID}" != "${PROJECT_ID}" ]]; then
    local REQUIRED_FLEET_APIS; REQUIRED_FLEET_APIS="$(required_fleet_apis | tr '\n' ' ')"
    if [[ -n "${REQUIRED_FLEET_APIS// }" ]]; then
      # shellcheck disable=SC2086
      retry 3 gcloud services enable --project="${FLEET_ID}" ${REQUIRED_FLEET_APIS}
    fi
  fi
}

#######
# valid_pool_query takes an integer argument: the minimum vCPU requirement.
# It outputs to stdout a query for `gcloud container node-pools list`
#######
valid_pool_query() {
  cat <<EOF | tr '\n' ' '
    config.machineType.split(sep="-").slice(-1:) >= $1
EOF
}

get_istio_deployment_count(){
  local OUTPUT
  OUTPUT="$(retry 3 kubectl get deployment \
    -n istio-system \
    --ignore-not-found=true)"
  grep -c istiod <<EOF || true
$OUTPUT
EOF
}

# For GCP: project number corresponds to the (optional) ASM Fleet project or the (default) cluster's project.
# For non-GCP: project number corresponds to the (required) ASM Fleet project.
get_project_number() {
  local FLEET_ID; FLEET_ID="${1}"
  local RESULT; RESULT=""

  info "Checking for project ${FLEET_ID}..."

  PROJECT_NUMBER="$(gcloud projects describe "${FLEET_ID}" --format="value(projectNumber)")"; readonly PROJECT_NUMBER

  if [[ -z "${PROJECT_NUMBER}" ]]; then
    { read -r -d '' MSG; fatal "${MSG}"; } <<EOF || true
Unable to find project ${FLEET_ID}. Please verify the spelling and try
again. To see a list of your projects, run:
  gcloud projects list --format='value(project_id)'
EOF
  fi
}

list_valid_pools() {
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"

  gcloud container node-pools list \
    --project="${PROJECT_ID}" \
    --region "${CLUSTER_LOCATION}" \
    --cluster "${CLUSTER_NAME}" \
    --filter "$(valid_pool_query "${1}")"\
    --format=json
}

get_enabled_apis() {
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local OUTPUT
  OUTPUT="$(retry 3 gcloud services list \
    --enabled \
    --format='get(config.name)' \
    --project="${PROJECT_ID}")"
  echo "${OUTPUT}" | tr '\n' ','
}

mesh_id_label() {
  echo "mesh_id=proj-${PROJECT_NUMBER}"
}

get_cluster_labels() {
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"

  info "Reading labels for ${CLUSTER_LOCATION}/${CLUSTER_NAME}..."
  local LABELS
  LABELS="$(retry 2 gcloud container clusters describe "${CLUSTER_NAME}" \
    --zone="${CLUSTER_LOCATION}" \
    --project="${PROJECT_ID}" \
    --format='value(resourceLabels)[delimiter=","]')";
  echo "${LABELS}"
}

generate_membership_name() {
  if is_gcp; then
    local PROJECT_ID; PROJECT_ID="${1}"
    local CLUSTER_LOCATION; CLUSTER_LOCATION="${2}"
    local CLUSTER_NAME; CLUSTER_NAME="${3}"

    local MEMBERSHIP_NAME
    MEMBERSHIP_NAME="${CLUSTER_NAME}"
    if [[ "$(retry 2 gcloud container hub memberships list --format='value(name)' \
    --project "${PROJECT_ID}" | grep -c "^${MEMBERSHIP_NAME}$" || true)" -ne 0 ]]; then
      MEMBERSHIP_NAME="${CLUSTER_NAME}-${PROJECT_ID}-${CLUSTER_LOCATION}"
    fi
    if [[ "${#MEMBERSHIP_NAME}" -gt "${KUBE_TAG_MAX_LEN}" ]] || [[ "$(retry 2 gcloud container hub \
    memberships list --format='value(name)' --project "${PROJECT_ID}" | grep -c \
    "^${MEMBERSHIP_NAME}$" || true)" -ne 0 ]]; then
      local RAND
      RAND="$(tr -dc "a-z0-9" </dev/urandom | head -c8 || true)"
      MEMBERSHIP_NAME="${CLUSTER_NAME:0:54}-${RAND}"
    fi
  else
    MEMBERSHIP_NAME="$(date +%s%N)"
  fi
  echo "${MEMBERSHIP_NAME}"
}

generate_secret_name() {
  local SECRET_NAME; SECRET_NAME="${1}"

  if [[ "${#SECRET_NAME}" -gt "${KUBE_TAG_MAX_LEN}" ]]; then
    local DIGEST
    DIGEST="$(echo "${SECRET_NAME}" | sha256sum | head -c20 || true)"
    SECRET_NAME="${SECRET_NAME:0:42}-${DIGEST}"
  fi

  echo "${SECRET_NAME}"
}

register_cluster() {
  if is_cluster_registered; then return; fi

  if is_gcp; then
    if can_modify_gcp_components; then
      enable_workload_identity
    else
      exit_if_no_workload_identity
    fi
  fi
  populate_cluster_values

  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"
  local GKE_CLUSTER_URI; GKE_CLUSTER_URI="$(context_get-option "GKE_CLUSTER_URI")"
  local MEMBERSHIP_NAME; MEMBERSHIP_NAME="$(generate_membership_name "${PROJECT_ID}" "${CLUSTER_LOCATION}" "${CLUSTER_NAME}")"
  info "Registering the cluster as ${MEMBERSHIP_NAME}..."
  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"
  local KCF; KCF="$(context_get-option "KUBECONFIG")"
  local KCC; KCC="$(context_get-option "CONTEXT")"

  if [[ "${FLEET_ID}" != "${PROJECT_ID}" ]]; then
    ensure_cross_project_service_accounts "${FLEET_ID}" "${PROJECT_ID}"
  fi

  local CMD
  CMD="gcloud container hub memberships register ${MEMBERSHIP_NAME}"
  CMD="${CMD} --project=${FLEET_ID}"
  CMD="${CMD} --enable-workload-identity"
  if is_gcp; then
    CMD="${CMD} --gke-uri=${GKE_CLUSTER_URI}"
  else
    CMD="${CMD} --kubeconfig=${KCF} --context=${KCC}"
  fi
  # shellcheck disable=SC2086
  retry 2 run_command ${CMD}
}

add_cluster_labels(){
  local LABELS; LABELS="$(get_cluster_labels)";

  local WANT; WANT="$(mesh_id_label)"

  local NOTFOUND; NOTFOUND="$(find_missing_strings "${WANT}" "${LABELS}")"

  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"

  if [[ -z "${NOTFOUND}" ]]; then return 0; fi

  if [[ -n "${LABELS}" ]]; then
    LABELS="${LABELS},"
  fi
  LABELS="${LABELS}${NOTFOUND}"

  info "Adding labels to ${CLUSTER_LOCATION}/${CLUSTER_NAME}..."
  retry 2 gcloud container clusters update "${CLUSTER_NAME}" \
    --project="${PROJECT_ID}" \
    --zone="${CLUSTER_LOCATION}" \
    --update-labels="${LABELS}"
}

populate_fleet_info() {
  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"
  local HUB_MEMBERSHIP_ID; HUB_MEMBERSHIP_ID="$(context_get-option "HUB_MEMBERSHIP_ID")"
  local HUB_IDP_URL; HUB_IDP_URL="$(context_get-option "HUB_IDP_URL")"

  if [[ -n "${FLEET_ID}" && \
    -n "${HUB_MEMBERSHIP_ID}" && \
    -n "${HUB_IDP_URL}" ]]; then return; fi

  if ! is_membership_crd_installed; then return; fi
HUB_MEMBERSHIP_ID="$(kubectl get memberships.hub.gke.io membership -o=json | jq .spec.owner.id | sed 's/^\"\/\/\(autopush-\)\{0,1\}gkehub\(.sandbox\)\{0,1\}.googleapis.com\/projects\/\(.*\)\/locations\/global\/memberships\/\(.*\)\"$/\4/g')"
  context_set-option "HUB_MEMBERSHIP_ID" "${HUB_MEMBERSHIP_ID}"
  HUB_IDP_URL="$(kubectl get memberships.hub.gke.io membership -o=jsonpath='{.spec.identity_provider}')"
  context_set-option "HUB_IDP_URL" "${HUB_IDP_URL}"
}

create_istio_namespace() {
  info "Creating istio-system namespace..."

  if istio_namespace_exists; then return; fi

  retry 2 kubectl create ns istio-system
}

label_istio_namespace() {
  local NETWORK_ID; NETWORK_ID="$(context_get-option "NETWORK_ID")"
  local NETWORK_LABEL; NETWORK_LABEL="$(kubectl get ns istio-system -o json | jq -r '.metadata.labels."topology.istio.io/network"')"
  if [[ "${NETWORK_LABEL}" = 'null' ]]; then
    retry 2 kubectl label ns istio-system "topology.istio.io/network=${NETWORK_ID}"
  else
    info "topology.istio.io/network is already set to ${NETWORK_LABEL} and will NOT be overridden."
  fi
}

register_gce_identity_provider() {
  info "Registering GCE Identity Provider in the cluster..."
  context_append "kubectlFiles" "asm/identity-provider/identityprovider-crd.yaml"
  context_append "kubectlFiles" "asm/identity-provider/googleidp.yaml"
}

get_auth_token() {
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local TOKEN; TOKEN="$(retry 2 gcloud --project="${PROJECT_ID}" auth print-access-token)"
  echo "${TOKEN}"
}
parse_args() {
  # shellcheck disable=SC2064
  trap "$(shopt -p nocasematch)" RETURN
  shopt -s nocasematch

  local OPTIONAL_OVERLAY; OPTIONAL_OVERLAY=""
  local CUSTOM_OVERLAY; CUSTOM_OVERLAY=""
  REVISION_LABEL="$(context_get-option "REVISION_LABEL")"
  while [[ $# != 0 ]]; do
    case "${1}" in
      -l | --cluster_location | --cluster-location)
        arg_required "${@}"
        context_set-option "CLUSTER_LOCATION" "${2}"
        shift 2
        ;;
      -n | --cluster_name | --cluster-name)
        arg_required "${@}"
        context_set-option "CLUSTER_NAME" "${2}"
        shift 2
        ;;
      --kc | --kubeconfig)
        arg_required "${@}"
        context_set-option "KUBECONFIG" "${2}"
        context_set-option "KUBECONFIG_SUPPLIED" 1
        shift 2
        ;;
      --ctx | --context)
        arg_required "${@}"
        context_set-option "CONTEXT" "${2}"
        shift 2
        ;;
      -p | --project_id | --project-id)
        arg_required "${@}"
        context_set-option "PROJECT_ID" "${2}"
        shift 2
        ;;
      -m | --mode)
        warn "As of version 1.10 the --mode flag is deprecated and will be ignored."
        shift 2
        ;;
      --fleet_id | --fleet-id)
        arg_required "${@}"
        context_set-option "FLEET_ID" "${2}"
        shift 2
        ;;
      --network_id | --network-id)
        arg_required "${@}"
        context_set-option "NETWORK_ID" "${2}"
        shift 2
        ;;
      -c | --ca)
        arg_required "${@}"
        context_set-option "CA" "$(echo "${2}" | tr '[:upper:]' '[:lower:]')"
        shift 2
        ;;
      --ca_name | --ca-name)
        warn "The --ca_name argument is deprecated and will be removed in the next minor release, please use --ca_pool instead."
        warn "Execution will continue normally."
        sleep 1
        ;;
      --ca_pool | --ca-pool)
        arg_required "${@}"
        context_set-option "CA_NAME" "${2}"
        shift 2
        ;;
      -o | --option)
        arg_required "${@}"

        if [[ "${2}" == "hub-meshca" ]]; then
          info "Fleet workload identity pool is used as default for Mesh CA. No need to specify hub-meshca option."
          shift 2
          continue
        fi

        OPTIONAL_OVERLAY="${2},${OPTIONAL_OVERLAY}"
        context_set-option "OPTIONAL_OVERLAY" "${OPTIONAL_OVERLAY}"

        if [[ "${2}" == "vm" ]]; then
          context_set-option "USE_VM" 1
        fi
        shift 2
        ;;
      --co | --custom_overlay | --custom-overlay)
        arg_required "${@}"
        CUSTOM_OVERLAY="${2},${CUSTOM_OVERLAY}"
        context_set-option "CUSTOM_OVERLAY" "${CUSTOM_OVERLAY}"
        shift 2
        ;;
      -e | --enable_all | --enable-all)
        context_set-option "ENABLE_ALL" 1
        shift 1
        ;;
      --enable_cluster_roles | --enable-cluster-roles)
        context_set-option "ENABLE_CLUSTER_ROLES" 1
        shift 1
        ;;
      --enable_cluster_labels | --enable-cluster-labels)
        context_set-option "ENABLE_CLUSTER_LABELS" 1
        shift 1
        ;;
      --enable_gcp_apis | --enable-gcp-apis)
        context_set-option "ENABLE_GCP_APIS" 1
        shift 1
        ;;
      --enable_gcp_iam_roles | --enable-gcp-iam-roles)
        context_set-option "ENABLE_GCP_IAM_ROLES" 1
        shift 1
        ;;
      --enable_gcp_components | --enable-gcp-components)
        context_set-option "ENABLE_GCP_COMPONENTS" 1
        shift 1
        ;;
      --enable_registration | --enable-registration)
        context_set-option "ENABLE_REGISTRATION" 1
        shift 1
        ;;
      --enable_namespace_creation | --enable-namespace-creation)
        context_set-option "ENABLE_NAMESPACE_CREATION" 1
        shift 1
        ;;
      --enable_meshconfig_init | --enable-meshconfig-init)
        context_set-option "ENABLE_MESHCONFIG_INIT" 1
        shift 1
        ;;
      --managed)
        context_set-option "MANAGED" 1
        REVISION_LABEL="asm-managed"
        shift 1
        ;;
      --legacy)
        context_set-option "LEGACY" 1
        shift 1
        ;;
      --disable_canonical_service | --disable-canonical-service)
        context_set-option "DISABLE_CANONICAL_SERVICE" 1
        shift 1
        ;;
      --print_config | --print-config)
        context_set-option "PRINT_CONFIG" 1
        shift 1
        ;;
      -s | --service_account | --service-account)
        arg_required "${@}"
        context_set-option "SERVICE_ACCOUNT" "${2}"
        shift 2
        ;;
      -k | --key_file | --key-file)
        arg_required "${@}"
        context_set-option "KEY_FILE" "${2}"
        shift 2
        ;;
      -D | --output_dir | --output-dir)
        arg_required "${@}"
        context_set-option "OUTPUT_DIR" "${2}"
        shift 2
        ;;
      --dry_run | --dry-run)
        context_set-option "DRY_RUN" 1
        shift 1
        ;;
      --only_validate | --only-validate)
        warn "In version 1.11 the --only_validate flag will be deprecated and ignored."
        warn "Please use \"asmcli valdiate\" instead."
        context_set-option "ONLY_VALIDATE" 1
        shift 1
        ;;
      --only_enable | --only-enable)
        context_set-option "ONLY_ENABLE" 1
        shift 1
        ;;
      --ca_cert | --ca-cert)
        arg_required "${@}"
        context_set-option "CA_CERT" "${2}"
        context_set-option "CUSTOM_CA" 1
        shift 2
        ;;
      --ca_key | --ca-key)
        arg_required "${@}"
        context_set-option "CA_KEY" "${2}"
        context_set-option "CUSTOM_CA" 1
        shift 2
        ;;
      --root_cert | --root-cert)
        arg_required "${@}"
        context_set-option "CA_ROOT" "${2}"
        context_set-option "CUSTOM_CA" 1
        shift 2
        ;;
      --cert_chain | --cert-chain)
        arg_required "${@}"
        context_set-option "CA_CHAIN" "${2}"
        context_set-option "CUSTOM_CA" 1
        shift 2
        ;;
      -r | --revision_name | --revision-name)
        arg_required "${@}"
        context_set-option "CUSTOM_REVISION" 1
        REVISION_LABEL="${2}"
        shift 2
        ;;
      --platform)
        arg_required "${@}"
        context_set-option "PLATFORM" "$(echo "${2}" | tr '[:upper:]' '[:lower:]')"
        shift 2
        ;;
      --channel)
        arg_required "${@}"
        context_set-option "CHANNEL" "${2}"
        shift 2
        ;;
      -v | --verbose)
        context_set-option "VERBOSE" 1
        shift 1
        ;;
      -h | --help)
        context_set-option "PRINT_HELP" 1
        shift 1
        ;;
      --version)
        context_set-option "PRINT_VERSION" 1
        shift 1
        ;;
      *)
        fatal_with_usage "Unknown option ${1}"
        ;;
    esac
  done
  RAW_YAML="${REVISION_LABEL}-manifest-raw.yaml"; readonly RAW_YAML;
  EXPANDED_YAML="${REVISION_LABEL}-manifest-expanded.yaml"; readonly EXPANDED_YAML;
  readonly REVISION_LABEL

  local PRINT_HELP; PRINT_HELP="$(context_get-option "PRINT_HELP")"
  local PRINT_VERSION; PRINT_VERSION="$(context_get-option "PRINT_VERSION")"
  local VERBOSE; VERBOSE="$(context_get-option "VERBOSE")"
  if [[ "${PRINT_HELP}" -eq 1 || "${PRINT_VERSION}" -eq 1 ]]; then
    if [[ "${PRINT_VERSION}" -eq 1 ]]; then
      version_message
    elif [[ "${VERBOSE}" -eq 1 ]]; then
      usage
    else
      usage_short
    fi
    exit
  fi
}

x_parse_install_args() {
  # shellcheck disable=SC2064
  trap "$(shopt -p nocasematch)" RETURN
  shopt -s nocasematch

  REVISION_LABEL="$(context_get-option "REVISION_LABEL")"
  while [[ $# != 0 ]]; do
    case "${1}" in
      -l | --cluster_location | --cluster-location)
        arg_required "${@}"
        context_set-option "CLUSTER_LOCATION" "${2}"
        shift 2
        ;;
      -n | --cluster_name | --cluster-name)
        arg_required "${@}"
        context_set-option "CLUSTER_NAME" "${2}"
        shift 2
        ;;
      --kc | --kubeconfig)
        arg_required "${@}"
        context_set-option "KUBECONFIG" "${2}"
        context_set-option "KUBECONFIG_SUPPLIED" 1
        shift 2
        ;;
      --ctx | --context)
        arg_required "${@}"
        context_set-option "CONTEXT" "${2}"
        shift 2
        ;;
      -p | --project_id | --project-id)
        arg_required "${@}"
        context_set-option "PROJECT_ID" "${2}"
        shift 2
        ;;
      --fleet_id | --fleet-id)
        arg_required "${@}"
        context_set-option "FLEET_ID" "${2}"
        shift 2
        ;;
      --network_id | --network-id)
        arg_required "${@}"
        context_set-option "NETWORK_ID" "${2}"
        shift 2
        ;;
      --managed)
        context_set-option "MANAGED" 1
        shift 1
        ;;
      --legacy)
        context_set-option "LEGACY" 1
        shift 1
        ;;
      --use_vpcsc | --use-vpcsc)
        context_set-option "USE_VPCSC" 1
        shift 1
        ;;
      -e | --enable_all | --enable-all)
        context_set-option "ENABLE_ALL" 1
        shift 1
        ;;
      --enable_cluster_labels | --enable-cluster-labels)
        context_set-option "ENABLE_CLUSTER_LABELS" 1
        shift 1
        ;;
      --enable_gcp_apis | --enable-gcp-apis)
        context_set-option "ENABLE_GCP_APIS" 1
        shift 1
        ;;
      --enable_gcp_iam_roles | --enable-gcp-iam-roles)
        context_set-option "ENABLE_GCP_IAM_ROLES" 1
        shift 1
        ;;
      --enable_gcp_components | --enable-gcp-components)
        context_set-option "ENABLE_GCP_COMPONENTS" 1
        shift 1
        ;;
      --enable_registration | --enable-registration)
        context_set-option "ENABLE_REGISTRATION" 1
        shift 1
        ;;
      --enable_namespace_creation | --enable-namespace-creation)
        context_set-option "ENABLE_NAMESPACE_CREATION" 1
        shift 1
        ;;
      --use_managed_cni | --use-managed-cni)
        context_set-option "USE_MANAGED_CNI" 1
        shift 1
        ;;
      --disable_canonical_service | --disable-canonical-service)
        context_set-option "DISABLE_CANONICAL_SERVICE" 1
        shift 1
        ;;
      -s | --service_account | --service-account)
        arg_required "${@}"
        context_set-option "SERVICE_ACCOUNT" "${2}"
        shift 2
        ;;
      -k | --key_file | --key-file)
        arg_required "${@}"
        context_set-option "KEY_FILE" "${2}"
        shift 2
        ;;
      -D | --output_dir | --output-dir)
        arg_required "${@}"
        context_set-option "OUTPUT_DIR" "${2}"
        shift 2
        ;;
      --dry_run | --dry-run)
        context_set-option "DRY_RUN" 1
        shift 1
        ;;
      --channel)
        arg_required "${@}"
        context_set-option "CHANNEL" "${2}"
        shift 2
        ;;
      -v | --verbose)
        context_set-option "VERBOSE" 1
        shift 1
        ;;
      -h | --help)
        context_set-option "PRINT_HELP" 1
        shift 1
        ;;
      --version)
        context_set-option "PRINT_VERSION" 1
        shift 1
        ;;
      *)
        fatal_with_usage "Unknown option ${1}"
        ;;
    esac
  done
  RAW_YAML="${REVISION_LABEL}-manifest-raw.yaml"; readonly RAW_YAML;
  EXPANDED_YAML="${REVISION_LABEL}-manifest-expanded.yaml"; readonly EXPANDED_YAML;
  readonly REVISION_LABEL

  local PRINT_HELP; PRINT_HELP="$(context_get-option "PRINT_HELP")"
  local PRINT_VERSION; PRINT_VERSION="$(context_get-option "PRINT_VERSION")"
  local VERBOSE; VERBOSE="$(context_get-option "VERBOSE")"
  if [[ "${PRINT_HELP}" -eq 1 || "${PRINT_VERSION}" -eq 1 ]]; then
    if [[ "${PRINT_VERSION}" -eq 1 ]]; then
      version_message
    elif [[ "${VERBOSE}" -eq 1 ]]; then
      usage
    else
      usage_short
    fi
    exit
  fi
}
KUBE_TAG_MAX_LEN=63; readonly KUBE_TAG_MAX_LEN

gen_install_params() {
  local CA; CA="$(context_get-option "CA")"

  local PARAM_BUILDER="-f ${OPERATOR_MANIFEST}"
  for yaml_file in $(context_list "istioctlFiles"); do
    PARAM_BUILDER="${PARAM_BUILDER} -f ${yaml_file}"
  done

  if [[ "${K8S_MINOR}" -eq 15 ]]; then
    PARAM_BUILDER="${PARAM_BUILDER} -f ${BETA_CRD_MANIFEST}"
  fi

  if [[ "${CA}" == "citadel" ]]; then
    PARAM_BUILDER="${PARAM_BUILDER} -f ${CITADEL_MANIFEST}"
  fi

  echo "${PARAM_BUILDER}"
}

#######
# run_command takes a list of arguments that represents a command
# If DRY_RUN or VERBOSE is enabled, it will print the command, and if DRY_RUN is
# not enabled it runs the command.
#######
run_command() {
  local DRY_RUN; DRY_RUN="$(context_get-option "DRY_RUN")"
  local VERBOSE; VERBOSE="$(context_get-option "VERBOSE")"

  if [[ "${DRY_RUN}" -eq 1 ]]; then
    warn "Would have executed: ${*}"
    return
  elif [[ "${VERBOSE}" -eq 0 ]]; then
    "${@}" 2>/dev/null
    return "$?"
  fi
  info "Running: '${*}'"
  info "-------------"
  local RETVAL
  { "${@}"; RETVAL="$?"; } || true
  return $RETVAL
}

######
# check_curl calls curl and returns non-zero if the http code is not 200 or the
# curl command fails.
######
check_curl() {
  local TMPFILE; TMPFILE=$(mktemp)

  local HTTPCODE;
  local RETVAL;
  HTTPCODE=$(run_command curl --write-out '%{http_code}' --silent --show-error --output "$TMPFILE" "${@}")
  RETVAL="$?"
  if [[ "$RETVAL" != "0" ]] ; then
    return "$RETVAL"
  fi
  if [[ "$HTTPCODE" != "200" ]] ; then
    warn "HTTP response code: ${HTTPCODE}"
  fi
  cat "$TMPFILE"
  if [[ "$HTTPCODE" != "200" ]] ; then
    false
    return
  fi
}

#######
# retry takes an integer N as the first argument, and a list of arguments
# representing a command afterwards. It will retry the given command up to N
# times before returning 1. If the command is kubectl, it will try to
# re-get credentials in case something caused the k8s IP to change.
#######
retry() {
  local MAX_TRIES; MAX_TRIES="${1}";
  shift 1
  for i in $(seq 0 "${MAX_TRIES}"); do
    if [[ "${i}" -eq "${MAX_TRIES}" ]]; then
      break
    fi
    { "${@}" && return 0; } || true
    warn "Failed, retrying...($((i+1)) of ${MAX_TRIES})"
    sleep 2
  done
  local CMD="'$*'"
  warn "Command $CMD failed."
  false
}

find_missing_strings() {
  local NEEDLES; NEEDLES="${1}";
  local HAYSTACK; HAYSTACK="${2}";
  local NOTFOUND; NOTFOUND="";
  local EXITCODE; EXITCODE=0;

  while read -r needle; do
    EXITCODE=0
    grep -q "${needle}" <<EOF || EXITCODE=$?
${HAYSTACK}
EOF
    if [[ "${EXITCODE}" -ne 0 ]]; then
      NOTFOUND="${needle},${NOTFOUND}"
    fi
  done <<EOF
${NEEDLES}
EOF

  if [[ -n "${NOTFOUND}" ]]; then NOTFOUND="$(strip_trailing_commas "${NOTFOUND}")"; fi
  echo "${NOTFOUND}"
}

strip_trailing_commas() {
  # shellcheck disable=SC2001
  echo "${1}" | sed 's/,*$//g'
}

warn() {
  info "[WARNING]: ${1}" >&2
}

warn_pause() {
  warn "${1}"
  sleep 2
}

error() {
  info "[ERROR]: ${1}" >&2
}

info() {
  local VERBOSE; VERBOSE="$(context_get-option "VERBOSE")"
  if hash ts 2>/dev/null && [[ "${VERBOSE}" -eq 1 ]]; then
    echo "${SCRIPT_NAME}: ${1}" | TZ=utc ts '%Y-%m-%dT%.T' >&2
  else
    echo "${SCRIPT_NAME}: ${1}" >&2
  fi
}

validation_error() {
  error "${1}"
  if only_validate; then
    local VALIDATION_ERROR; VALIDATION_ERROR="$(context_get-option "VALIDATION_ERROR")"
    context_set-option "VALIDATION_ERROR" $((VALIDATION_ERROR + 1))
  else
    exit 2
  fi
}

fatal() {
  error "${1}"
  exit 2
}

fatal_with_usage() {
  error "${1}"
  usage_short >&2
  exit 2
}

prompt_user_for_value() {
  read -r -p "Please provide a value for ${1}:" VALUE
  if [[ -n "${VALUE}" ]]; then
    echo "${VALUE}"
  fi
}

prompt_default_no() {
  read -r -p "${1} [y/N] " response
  case "$response" in
      [yY][eE][sS]|[yY])
          return
          ;;
  esac
  false
}

starline() {
  echo "*****************************"
}

enable_common_message() {
  echo "Alternatively, use --enable_all|-e to allow this tool to handle all dependencies."
}

download_kpt() {
  local PLATFORM
  PLATFORM="$(get_platform "$(uname)" "$(uname -m)")"
  if [[ -z "${PLATFORM}" ]]; then
    fatal "$(uname) $(uname -m) is not a supported platform to perform installation from."
  fi

  local KPT_TGZ
  KPT_TGZ="https://github.com/GoogleContainerTools/kpt/releases/download/v0.39.3/kpt_${PLATFORM}-0.39.3.tar.gz"

  info "Downloading kpt.."
  curl -L "${KPT_TGZ}" | tar xz
  AKPT="$(apath -f kpt)"
}

get_platform() {
  local OS; OS="${1}"
  local ARCH; ARCH="${2}"
  local PLATFORM

  case "${OS}" in
    Linux ) PLATFORM="linux_amd64";;
    Darwin)
      if [[ "${ARCH}" == "arm64" ]]; then
        PLATFORM="darwin_arm64"
      else
        PLATFORM="darwin_amd64"
      fi
    ;;
  esac

  echo "${PLATFORM}"
}

download_asm() {
  local OS
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"

  case "$(uname)" in
    Linux ) OS="linux-amd64";;
    Darwin) OS="osx";;
    *     ) fatal "$(uname) is not a supported OS.";;
  esac

  info "Downloading ASM.."
  local TARBALL; TARBALL="istio-${RELEASE}-${OS}.tar.gz"
  if [[ -z "${_CI_ASM_PKG_LOCATION}" ]]; then
    curl -L "https://storage.googleapis.com/gke-release/asm/${TARBALL}" \
      | tar xz
  else
    local TOKEN; TOKEN="$(retry 2 gcloud --project="${PROJECT_ID}" auth print-access-token)"
    run_command curl -L "https://storage.googleapis.com/${_CI_ASM_PKG_LOCATION}/asm/${TARBALL}" \
      --header @- <<EOF | tar xz
Authorization: Bearer ${TOKEN}
EOF
  fi

  ln -s "${ISTIOCTL_REL_PATH}" .
  version_message > "${ASM_VERSION_FILE}"
}

download_kpt_package() {
  local SAMPLES_URL
  SAMPLES_URL="${KPT_URL/asm@/samples@}"

  info "Downloading ASM kpt package..."
  retry 3 kpt pkg get --auto-set=false "${KPT_URL}" asm
  retry 3 kpt pkg get --auto-set=false "${SAMPLES_URL}" samples

  local MANAGED; MANAGED="$(context_get-option "MANAGED")"
  local CA; CA="$(context_get-option "CA")"

  echo "${MANAGED} ${CA}" >| "${ASM_SETTINGS_FILE}"
}

should_download_kpt_package() {
  if [[ ! -f "${ASM_SETTINGS_FILE}" ]]; then return; fi

  local MANAGED; MANAGED="$(context_get-option "MANAGED")"
  local CA; CA="$(context_get-option "CA")"

  local PREV_MANAGED PREV_CA
  read -r PREV_MANAGED PREV_CA <"${ASM_SETTINGS_FILE}"

  if [[ "${MANAGED}" -ne "${PREV_MANAGED}" || "${PREV_CA}" != "${CA}" ]]; then
    warn "Configuration has changed since last run, scheduling re-download of kpt package"
    return
  fi

  false
}

# LTS releases don't have curl 7.55 so we can't use the @- construction,
# using -K keeps the token from printing if this script is run with -v
auth_header() {
  local TOKEN; TOKEN="${1}"
  echo "--header \"Authorization: Bearer ${TOKEN}\""
}

prepare_environment() {
  set_up_local_workspace
  validate_cli_dependencies

  if is_sa; then
    auth_service_account
  fi

  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"
  configure_kubectl "${PROJECT_ID}" "${CLUSTER_LOCATION}" "${CLUSTER_NAME}"

  if should_validate || can_modify_at_all; then
    local_iam_user > /dev/null
    if is_gcp && ! using_connect_gateway; then
      validate_gcp_resources
    fi
  fi

  if needs_asm && needs_kpt; then
    download_kpt
  fi
  readonly AKPT

  if needs_asm; then
    if ! necessary_files_exist; then
      download_asm
    fi
    if should_download_kpt_package; then
      download_kpt_package
    fi
    organize_kpt_files
  fi
}

init() {
  # BSD-style readlink apparently doesn't have the same -f toggle on readlink
  case "$(uname)" in
    Linux ) APATH="readlink";;
    Darwin) APATH="stat";;
    *);;
  esac
  readonly APATH

  local REVISION_LABEL
  KPT_BRANCH="${_CI_ASM_KPT_BRANCH:=main}"
  if [[ "${POINT}" == "alpha" ]]; then
    RELEASE="${MAJOR}.${MINOR}-alpha.${REV}"
    REVISION_LABEL="${_CI_REVISION_PREFIX}asm-${MAJOR}${MINOR}${POINT}"
  elif [[ "$(version_message)" =~ ^[0-9]+\.[0-9]+\.[0-9]+-asm\.[0-9]+\+config[0-9]+$ ]]; then
    RELEASE="${MAJOR}.${MINOR}.${POINT}-asm.${REV}"
    REVISION_LABEL="${_CI_REVISION_PREFIX}asm-${MAJOR}${MINOR}${POINT}-${REV}"
    KPT_BRANCH="${_CI_ASM_KPT_BRANCH:=$(version_message)}"
  else
    RELEASE="${MAJOR}.${MINOR}.${POINT}-asm.${REV}"
    REVISION_LABEL="${_CI_REVISION_PREFIX}asm-${MAJOR}${MINOR}${POINT}-${REV}"
  fi
  RELEASE_LINE="${MAJOR}.${MINOR}."
  PREVIOUS_RELEASE_LINE="${MAJOR}.$(( MINOR - 1 ))."
  context_set-option "REVISION_LABEL" "${REVISION_LABEL}"
  readonly RELEASE; readonly RELEASE_LINE; readonly PREVIOUS_RELEASE_LINE; readonly KPT_BRANCH;

  KPT_URL="https://github.com/GoogleCloudPlatform/anthos-service-mesh-packages"
  KPT_URL="${KPT_URL}.git/asm@${KPT_BRANCH}"; readonly KPT_URL;
  ISTIO_FOLDER_NAME="istio-${RELEASE}"; readonly ISTIO_FOLDER_NAME;
  ISTIOCTL_REL_PATH="${ISTIO_FOLDER_NAME}/bin/istioctl"; readonly ISTIOCTL_REL_PATH;
  BASE_REL_PATH="${_CI_BASE_REL_PATH:-${ISTIO_FOLDER_NAME}/manifests/charts/base/files/gen-istio-cluster.yaml}"
  readonly BASE_REL_PATH
  PACKAGE_DIRECTORY="asm/istio"; readonly PACKAGE_DIRECTORY;
  VALIDATION_FIX_FILE_NAME="istiod-service.yaml"; readonly VALIDATION_FIX_FILE_NAME;
  VALIDATION_FIX_SERVICE="${PACKAGE_DIRECTORY}/${VALIDATION_FIX_FILE_NAME}"; readonly VALIDATION_FIX_SERVICE;
  OPTIONS_DIRECTORY="${PACKAGE_DIRECTORY}/options"; readonly OPTIONS_DIRECTORY;
  OPERATOR_MANIFEST="${PACKAGE_DIRECTORY}/istio-operator.yaml"; readonly OPERATOR_MANIFEST;
  BETA_CRD_MANIFEST="${OPTIONS_DIRECTORY}/v1beta1-crds.yaml"; readonly BETA_CRD_MANIFEST;
  CITADEL_MANIFEST="${OPTIONS_DIRECTORY}/citadel-ca.yaml"; readonly CITADEL_MANIFEST;
  MANAGED_CNI="${OPTIONS_DIRECTORY}/cni-managed.yaml"; readonly MANAGED_CNI;
  MANAGED_MANIFEST="${OPTIONS_DIRECTORY}/managed-control-plane.yaml"; readonly MANAGED_MANIFEST;
  MANAGED_WEBHOOKS="${OPTIONS_DIRECTORY}/managed-control-plane-webhooks.yaml"; readonly MANAGED_WEBHOOKS;
  EXPOSE_ISTIOD_DEFAULT_SERVICE="${PACKAGE_DIRECTORY}/expansion/expose-istiod.yaml"; readonly EXPOSE_ISTIOD_DEFAULT_SERVICE;
  EXPOSE_ISTIOD_REVISION_SERVICE="${PACKAGE_DIRECTORY}/expansion/expose-istiod-rev.yaml"; readonly EXPOSE_ISTIOD_REVISION_SERVICE;
  EXPANSION_GATEWAY_FILE="${PACKAGE_DIRECTORY}/expansion/vm-eastwest-gateway.yaml"; readonly EXPANSION_GATEWAY_FILE;
  CANONICAL_CONTROLLER_MANIFEST="asm/canonical-service/controller.yaml"; readonly CANONICAL_CONTROLLER_MANIFEST;
  ASM_VERSION_FILE=".asm_version"; readonly ASM_VERSION_FILE;
  ASM_SETTINGS_FILE=".asm_settings"; readonly ASM_SETTINGS_FILE;

  CRD_CONTROL_PLANE_REVISION="asm/control-plane-revision/crd.yaml"; readonly CRD_CONTROL_PLANE_REVISION;
  CR_CONTROL_PLANE_REVISION_REGULAR="asm/control-plane-revision/cr_regular.yaml"; readonly CR_CONTROL_PLANE_REVISION_REGULAR;
  CR_CONTROL_PLANE_REVISION_RAPID="asm/control-plane-revision/cr_rapid.yaml"; readonly CR_CONTROL_PLANE_REVISION_RAPID;
  CR_CONTROL_PLANE_REVISION_STABLE="asm/control-plane-revision/cr_stable.yaml"; readonly CR_CONTROL_PLANE_REVISION_STABLE;
  CR_CONTROL_PLANE_REVISION_REGULAR_RECONCILED="asm/control-plane-revision/cr_regular_reconciled.yaml"; readonly CR_CONTROL_PLANE_REVISION_REGULAR_RECONCILED;
  CR_CONTROL_PLANE_REVISION_RAPID_RECONCILED="asm/control-plane-revision/cr_rapid_reconciled.yaml"; readonly CR_CONTROL_PLANE_REVISION_RAPID_RECONCILED;
  CR_CONTROL_PLANE_REVISION_STABLE_RECONCILED="asm/control-plane-revision/cr_stable_reconciled.yaml"; readonly CR_CONTROL_PLANE_REVISION_STABLE_RECONCILED;
  REVISION_LABEL_REGULAR="asm-managed"; readonly REVISION_LABEL_REGULAR
  REVISION_LABEL_RAPID="asm-managed-rapid"; readonly REVISION_LABEL_RAPID
  REVISION_LABEL_STABLE="asm-managed-stable"; readonly REVISION_LABEL_STABLE

  AKUBECTL="$(which kubectl || true)"; readonly AKUBECTL;
  AGCLOUD="$(which gcloud || true)"; readonly AGCLOUD;
  AKPT="$(which kpt || true)"
}

### Convenience functions ###

apath() {
  "${APATH}" "${@}"
}

gcloud() {
  run_command "${AGCLOUD}" "${@}"
}

kubectl() {
  local KCF KCC HTTPS_PROXY
  KCF="$(context_get-option "KUBECONFIG")"
  KCC="$(context_get-option "CONTEXT")"
  HTTPS_PROXY="$(context_get-option "HTTPS_PROXY")"

  # Catch old codepaths that don't use context_set
  if [[ -z "${KCF}" ]]; then
    KCF="${KUBECONFIG}"
  fi

  # If we still
  if [[ -z "${KCF}" ]]; then
    KCF="$(mktemp)"
  fi

  local CMD
  CMD="${AKUBECTL}"
  if [[ -n "${KCF}" ]]; then
    CMD="${CMD} --kubeconfig ${KCF}"
  fi
  if [[ -n "${KCC}" ]]; then
    CMD="${CMD} --context ${KCC}"
  fi

  if [[ -n "${HTTPS_PROXY}" ]]; then
    # shellcheck disable=SC2086
    HTTPS_PROXY="${HTTPS_PROXY}" ${CMD} "${@}"
  else
    # shellcheck disable=SC2086
    run_command ${CMD} "${@}"
  fi
}

kpt() {
  run_command "${AKPT}" "${@}"
}

istioctl() {
  local KCF KCC HTTPS_PROXY
  KCF="$(context_get-option "KUBECONFIG")"
  KCC="$(context_get-option "CONTEXT")"
  HTTPS_PROXY="$(context_get-option "HTTPS_PROXY")"
  if [[ -z "${KCF}" ]]; then
    KCF="${KUBECONFIG}"
  fi

  if [[ -n "${HTTPS_PROXY}" ]]; then
    HTTPS_PROXY="${HTTPS_PROXY}" run_command "$(istioctl_path)" --kubeconfig "${KCF}" --context "${KCC}" "${@}"
  else
    run_command "$(istioctl_path)" --kubeconfig "${KCF}" --context "${KCC}" "${@}"
  fi
}

istioctl_path() {
  if [[ -n "${_CI_ISTIOCTL_REL_PATH}" && -f "${_CI_ISTIOCTL_REL_PATH}" ]]; then
    echo "${_CI_ISTIOCTL_REL_PATH}"
  else
    echo "./${ISTIOCTL_REL_PATH}"
  fi
}

verify_connectivity() {
  info "Verifying connectivity (10s)..."
  local ADDR
  ADDR="$(kubectl config view --minify=true -ojson | \
    jq .clusters[0].cluster.server -r)"
  ADDR="${ADDR:8:${#ADDR}}"
  ADDR="${ADDR%:*}"

  local RETVAL; RETVAL=0;
  run_command nc -zvw 10 "${ADDR}" 443 || RETVAL=$?
  if [[ "${RETVAL}" -ne 0 ]]; then
    { read -r -d '' MSG; fatal "${MSG}"; } <<EOF || true
Couldn't connect to ${CLUSTER_NAME}.
If this is a private cluster, verify that the correct firewall rules are applied.
https://cloud.google.com/service-mesh/docs/gke-install-overview#requirements
EOF
  fi
}

add_trust_domain_alias() {
  local TRUST_DOMAIN_ALIASES
  TRUST_DOMAIN_ALIASES="$(context_get-option "TRUST_DOMAIN_ALIASES")"
  if [[ "${TRUST_DOMAIN_ALIASES}" == *${1}* ]]; then
    return
  fi
  TRUST_DOMAIN_ALIASES="${TRUST_DOMAIN_ALIASES} ${1}"
  context_set-option "TRUST_DOMAIN_ALIASES" "${TRUST_DOMAIN_ALIASES}"
}

auth_service_account() {
  local SERVICE_ACCOUNT; SERVICE_ACCOUNT="$(context_get-option "SERVICE_ACCOUNT")"
  local KEY_FILE; KEY_FILE="$(context_get-option "KEY_FILE")"
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"

  info "Authorizing ${SERVICE_ACCOUNT} with ${KEY_FILE}..."
  gcloud auth activate-service-account \
    --project="${PROJECT_ID}" \
    "${SERVICE_ACCOUNT}" \
    --key-file="${KEY_FILE}"
}

#######
# set_up_local_workspace does everything that the script needs to avoid
# polluting the environment or current working directory
#######
set_up_local_workspace() {
  local OUTPUT_DIR; OUTPUT_DIR="$(context_get-option "OUTPUT_DIR")"
  local KUBECONFIG_SUPPLIED; KUBECONFIG_SUPPLIED="$(context_get-option "KUBECONFIG_SUPPLIED")"
  local KUBECONFIG; KUBECONFIG="$(context_get-option "KUBECONFIG")"

  info "Setting up necessary files..."
  if [[ -z "${OUTPUT_DIR}" ]]; then
    info "Creating temp directory..."
    OUTPUT_DIR="$(mktemp -d)"
    if [[ -z "${OUTPUT_DIR}" ]]; then
      fatal "Encountered error when running mktemp -d!"
    fi
    info ""
    info "$(starline)"
    info "No output folder was specified with --output_dir|-D, so configuration and"
    info "binaries will be stored in the following directory."
    info "${OUTPUT_DIR}"
    info "$(starline)"
    info ""
    sleep 2
  else
    OUTPUT_DIR="$(apath -f "${OUTPUT_DIR}")"
    if [[ ! -a "${OUTPUT_DIR}" ]]; then
      if ! mkdir -p "${OUTPUT_DIR}"; then
        fatal "Failed to create directory ${OUTPUT_DIR}"
      fi
    elif [[ ! -d "${OUTPUT_DIR}" ]]; then
      fatal "${OUTPUT_DIR} exists and is not a directory, please specify another directory."
    fi
  fi

  if [[ -x "${OUTPUT_DIR}/kpt" ]]; then AKPT="$(apath -f "${OUTPUT_DIR}/kpt")"; fi

  pushd "$OUTPUT_DIR" > /dev/null
  context_set-option "OUTPUT_DIR" "${OUTPUT_DIR}"

  if [[ "${KUBECONFIG_SUPPLIED}" -eq 0 ]]; then
    KUBECONFIG="$(pwd)/asm_kubeconfig"
    context_set-option "KUBECONFIG" "${KUBECONFIG}"
  fi

  if [[ -n "${KUBECONFIG}" && ! -f "${KUBECONFIG}" ]]; then
    touch "${KUBECONFIG}"
  fi

  info "Using ${KUBECONFIG} as the kubeconfig..."
}

organize_kpt_files() {
  local ABS_YAML
  local CUSTOM_OVERLAY; CUSTOM_OVERLAY="$(context_get-option "CUSTOM_OVERLAY")"
  local OPTIONAL_OVERLAY; OPTIONAL_OVERLAY="$(context_get-option "OPTIONAL_OVERLAY")"

  while read -d ',' -r yaml_file; do
    ABS_YAML="${OPTIONS_DIRECTORY}/${yaml_file}.yaml"
    if [[ ! -f "${ABS_YAML}" ]]; then
    { read -r -d '' MSG; fatal "${MSG}"; } <<EOF || true
Couldn't find yaml file ${yaml_file}.
See directory $(apath -f "${OPTIONS_DIRECTORY}") for available options.
EOF
    fi
    CUSTOM_OVERLAY="${ABS_YAML},${CUSTOM_OVERLAY}"
  done <<EOF
${OPTIONAL_OVERLAY}
EOF

  context_set-option "CUSTOM_OVERLAY" "${CUSTOM_OVERLAY}"
  context_set-option "OPTIONAL_OVERLAY" ""  # unset OPTIONAL_OVERLAY
}

# This is a workaround for https://github.com/istio/istio/issues/30632
# which doesn't handle files with multiple operator specs correctly.
# This will split all of the files based off of the yaml document separator.
handle_multi_yaml_bug() {
  local CUSTOM_OVERLAY; CUSTOM_OVERLAY="$(context_get-option "CUSTOM_OVERLAY")"
  local CSPLIT_OUTPUT; CSPLIT_OUTPUT="";
  local BASE_NAME
  while read -d ',' -r yaml_file; do
    BASE_NAME="$(basename "${yaml_file}")"
    if [[ "$(csplit -f "overlay-${BASE_NAME}" "${yaml_file}" '/^---$/' '{*}' | wc -l)" -eq 1 ]]; then
      CSPLIT_OUTPUT="${CSPLIT_OUTPUT},${yaml_file}"
    else
      for split_file in overlay-"${BASE_NAME}"*; do
        if [[ -s "${split_file}" ]]; then
          CSPLIT_OUTPUT="${CSPLIT_OUTPUT},$(apath -f "${split_file}")"
        fi
      done
    fi
  done <<EOF
${CUSTOM_OVERLAY}
EOF
  if [[ -n "${CSPLIT_OUTPUT}" ]]; then
    CUSTOM_OVERLAY="${CSPLIT_OUTPUT:1:${#CSPLIT_OUTPUT}},"
    context_set-option "CUSTOM_OVERLAY" "${CUSTOM_OVERLAY}"
  fi
}

post_process_istio_yamls() {
  handle_multi_yaml_bug

  while read -d ',' -r yaml_file; do
    context_append "istioctlFiles" "${yaml_file}"
  done <<EOF
$(context_get-option "CUSTOM_OVERLAY")
EOF
}

necessary_files_exist() {
  local OUTPUT_DIR; OUTPUT_DIR="$(context_get-option "OUTPUT_DIR")"

  if [[ ! -f "${OUTPUT_DIR}/${ISTIOCTL_REL_PATH}" ]]; then
    false
    return
  elif [[ ! -f "${OUTPUT_DIR}/${OPERATOR_MANIFEST}" ]]; then
    false
    return
  fi

  # Refuse to overwrite configuration downloaded from a different version
  if [[ ! -f "${OUTPUT_DIR}/${ASM_VERSION_FILE}" ]]; then
    warn "Re-using existing configuration in ${OUTPUT_DIR}."
    warn_pause "If this was unintentional, please re-run with a different output directory."
    return
  fi

  local EXISTING_VER; EXISTING_VER="$(cat "${ASM_VERSION_FILE}")";
  if [[ "${EXISTING_VER}" != "$(version_message)" ]]; then
    { read -r -d '' MSG; fatal "${MSG}"; } <<EOF || true
The existing configuration in ${OUTPUT_DIR} is from a different version.
Existing: ${EXISTING_VER}
Current: $(version_message)
Please try again and specify a different output directory.
EOF
  fi
}

populate_cluster_values() {
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"
  local NETWORK_ID; NETWORK_ID="$(context_get-option "NETWORK_ID")"
  local CLUSTER_DATA

  if is_gcp; then
    CLUSTER_DATA="$(retry 2 gcloud container clusters describe "${CLUSTER_NAME}" \
      --zone="${CLUSTER_LOCATION}" \
      --project="${PROJECT_ID}" \
      --format='value(selfLink, network)')"
    read -r NEW_GKE_CLUSTER_URI NEW_NETWORK_ID <<EOF
${CLUSTER_DATA}
EOF

    if not_null "${NEW_GKE_CLUSTER_URI}"; then
      context_set-option "GKE_CLUSTER_URI" "${NEW_GKE_CLUSTER_URI}"
    fi
    if not_null "${NEW_NETWORK_ID}"; then
      context_set-option "NETWORK_ID" "${PROJECT_ID}-${NEW_NETWORK_ID}"
    fi
  else
    if [[ -z "${NETWORK_ID}" ]]; then
      context_set-option "NETWORK_ID" "default"
    fi
  fi
}

# Reads in stdin, expected in the form of kubectl config get-contexts
# output and isolates the default context's cluster value.
get_context_cluster() {
  grep '^\*' | cut -c2- | sed 's/\([[:blank:]]\)*\1/\1/g' | cut -d ' ' -f 3
}

init_meshconfig_curl() {
  local POST_DATA; POST_DATA="${1}"
  local ID; ID="${2}"
  run_command curl --request POST --fail \
    --data "${POST_DATA}" -o /dev/null \
    "https://meshconfig.googleapis.com/v1alpha1/projects/${ID}:initialize" \
    --header "X-Server-Timeout: 600" \
    --header "Content-Type: application/json" \
    -K <(auth_header "$(get_auth_token)")
}

get_gke_release_channel() {
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"
  gcloud container clusters describe \
    --project="${PROJECT_ID}" \
    --region "${CLUSTER_LOCATION}" \
    "${CLUSTER_NAME}" \
    --format="value(releaseChannel.channel)"
}

get_cr_channels() {
  local CHANNEL; CHANNEL="$(context_get-option "CHANNEL")"
  if [[ -n "${CHANNEL}" ]]; then
    echo "${CHANNEL}"
  elif ! is_gcp; then
    echo regular
    echo rapid
  else
    local GKE_CHANNEL; GKE_CHANNEL="$(get_gke_release_channel)"
    case "${GKE_CHANNEL}" in
      regular)
        echo rapid
        echo regular
        ;;
      rapid)
        echo rapid
        ;;
      stable)
        echo stable
        ;;
      *)
        echo rapid
        echo regular
        ;;
    esac
  fi
}

get_cr_yaml() {
  local CHANNEL; CHANNEL="${1}"
  local LEGACY; LEGACY="$(context_get-option "LEGACY")"
  local CR REVISION
  case "${CHANNEL}" in
    regular)
      if ! is_legacy; then
        CR="${CR_CONTROL_PLANE_REVISION_REGULAR}"
      else
        CR="${CR_CONTROL_PLANE_REVISION_REGULAR_RECONCILED}"
      fi
      REVISION="${REVISION_LABEL_REGULAR}"
      ;;
    stable)
      if ! is_legacy; then
        CR="${CR_CONTROL_PLANE_REVISION_STABLE}"
      else
        CR="${CR_CONTROL_PLANE_REVISION_STABLE_RECONCILED}"
      fi
      REVISION="${REVISION_LABEL_STABLE}"
      ;;
    *)
      if ! is_legacy; then
        CR="${CR_CONTROL_PLANE_REVISION_RAPID}"
      else
        CR="${CR_CONTROL_PLANE_REVISION_RAPID_RECONCILED}"
      fi
      REVISION="${REVISION_LABEL_RAPID}"
      ;;
  esac
  echo "${CR} ${REVISION}"
}

ensure_cross_project_service_accounts() {
  local FLEET_ID; FLEET_ID="${1}"
  local PROJECT_ID; PROJECT_ID="${2}"

  if ! is_gcp; then return; fi

  local FLEET_HOST_PROJECT_NUMBER
  FLEET_HOST_PROJECT_NUMBER="$(gcloud projects describe "${FLEET_ID}" --format "value(projectNumber)")"

  local FLEET_SA
  local MESH_SA
  FLEET_SA="serviceAccount:service-${FLEET_HOST_PROJECT_NUMBER}@gcp-sa-gkehub.iam.gserviceaccount.com"
  MESH_SA="serviceAccount:service-${FLEET_HOST_PROJECT_NUMBER}@gcp-sa-servicemesh.iam.gserviceaccount.com"

  if ! ensure_cross_project_sa "${FLEET_ID}" "${PROJECT_ID}" "${FLEET_SA}" "roles/gkehub.serviceAgent"; then
    warn "The Fleet service account may not have been created for the Fleet hosted in ${FLEET_ID}."
    warn "Please refer to https://cloud.google.com/anthos/multicluster-management/connect/prerequisites#gke-cross-project"
    warn "for information on how to create the identity and grant permissions. You may also re-run this command"
    warn "with either the --enable-all or --enable-gcp-iam-roles flag to automatically create the IAM bindings."
  fi

  if ! ensure_cross_project_sa "${FLEET_ID}" "${PROJECT_ID}" "${MESH_SA}" "roles/anthosservicemesh.serviceAgent"; then
    warn "The Mesh service account may not have been created for the Fleet hosted in ${FLEET_ID}."
    warn "Please add an IAM binding for service-${FLEET_HOST_PROJECT_NUMBER}@gcp-sa-servicemesh.iam.gserviceaccount.com"
    warn "with a role binding for roles/anthosservicemesh.serviceAgent. You may also re-run this command"
    warn "with either the --enable-all or --enable-gcp-iam-roles flag to automatically create the IAM bindings."
  fi
}

ensure_cross_project_sa() {
  local FLEET_ID; FLEET_ID="${1}"
  local PROJECT_ID; PROJECT_ID="${2}"
  local SA_NAME; SA_NAME="${3}"
  local ROLE; ROLE="${4}"
  local ENABLE_ALL; ENABLE_ALL="$(context_get-option "ENABLE_ALL")"
  local ENABLE_GCP_IAM_ROLES; ENABLE_GCP_IAM_ROLES="$(context_get-option "ENABLE_GCP_IAM_ROLES")"

  local FLEET_POLICIES
  FLEET_POLICIES="$(gcloud projects get-iam-policy "${FLEET_ID}" --format=json)"

  if [[ -z "${FLEET_POLICIES}" ]]; then
    false
    return
  fi

  if ! echo "${FLEET_POLICIES}" | grep -q "${SA_NAME}"; then
    false
    return
  fi

  local PROJECT_POLICY_MEMBERS
  PROJECT_POLICY_MEMBERS="$(gcloud projects get-iam-policy "${PROJECT_ID}" --format=json)"

  if [[ -z "${PROJECT_POLICY_MEMBERS}" ]]; then
    false
    return
  fi

  PROJECT_POLICY_MEMBERS="$(echo "${PROJECT_POLICY_MEMBERS}" | jq '.bindings[] | select(.role == "'"${ROLE}"'")')"

  if [[ -n "${PROJECT_POLICY_MEMBERS}" ]]; then
    PROJECT_POLICY_MEMBERS="$(echo "${PROJECT_POLICY_MEMBERS}" | jq '.members[]')"
  fi

  if [[ "${PROJECT_POLICY_MEMBERS}" == *"${SA_NAME}"* ]]; then
    return
  fi


  if [[ "${ENABLE_ALL}" -eq 1 || "${ENABLE_GCP_IAM_ROLES}" -eq 1 ]]; then
    bind_user_to_iam_policy "${ROLE}" "${SA_NAME}"
    true
    return
  fi
  false
}

validate_revision_label() {
  # Matches DNS label formats of RFC 1123
  local DNS_1123_LABEL_MAX_LEN; DNS_1123_LABEL_MAX_LEN=63;
  readonly DNS_1123_LABEL_MAX_LEN

  local DNS_1123_LABEL_FMT; DNS_1123_LABEL_FMT="^[a-zA-Z0-9]([-a-zA-Z0-9]*[a-zA-Z0-9])?$";
  readonly DNS_1123_LABEL_FMT

  if [[ ${#REVISION_LABEL} -gt ${DNS_1123_LABEL_MAX_LEN} ]]; then
    fatal "Revision label cannot be longer than $DNS_1123_LABEL_MAX_LEN."
  fi

  if ! [[ "${REVISION_LABEL}" =~ ${DNS_1123_LABEL_FMT} ]]; then
    fatal "Revision label does not follow RFC 1123 formatting convention."
  fi
}

validate_hub() {
  if ! is_cluster_registered && ! can_register_cluster ; then
    context_set-option "USE_HUB_WIP" 0
  fi
}

### Environment validation functions ###
validate_environment() {
  if is_gcp; then
    validate_node_pool
  fi
  validate_k8s
  if is_gcp; then
    validate_expected_control_plane
  fi
  validate_no_ingress_gateway
}

validate_cli_dependencies() {
  local NOTFOUND; NOTFOUND="";
  local EXITCODE; EXITCODE=0;
  local CUSTOM_CA; CUSTOM_CA="$(context_get-option "CUSTOM_CA")"

  info "Checking installation tool dependencies..."
  while read -r dependency; do
    EXITCODE=0
    hash "${dependency}" 2>/dev/null || EXITCODE=$?
    if [[ "${EXITCODE}" -ne 0 ]]; then
      NOTFOUND="${dependency},${NOTFOUND}"
    fi
  done <<EOF
awk
$AGCLOUD
grep
jq
$AKUBECTL
sed
tr
head
csplit
EOF

  while read -r FLAG; do
    if [[ -z "${!FLAG}" ]]; then
      NOTFOUND="${FLAG},${NOTFOUND}"
    fi
  done <<EOF
AKUBECTL
AGCLOUD
EOF

  if [[ "${CUSTOM_CA}" -eq 1 ]]; then
    EXITCODE=0
    hash openssl 2>/dev/null || EXITCODE=$?
    if [[ "${EXITCODE}" -ne 0 ]]; then
      NOTFOUND="openssl,${NOTFOUND}"
    fi
  fi

  if [[ "${#NOTFOUND}" -gt 1 ]]; then
    NOTFOUND="$(strip_trailing_commas "${NOTFOUND}")"
    for dep in $(echo "${NOTFOUND}" | tr ' ' '\n'); do
      warn "Dependency not found: ${dep}"
    done
    fatal "One or more dependencies were not found. Please install them and retry."
  fi

  local OS
  # shellcheck disable=SC2064
  trap "$(shopt -p nocasematch)" RETURN
  shopt -s nocasematch
  if [[ "$(uname -m)" != "x86_64" ]]; then
    fatal "Installation is only supported on x86_64."
  fi
}

validate_gcp_resources() {
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  validate_cluster "${PROJECT_ID}" "${CLUSTER_LOCATION}" "${CLUSTER_NAME}"
}

validate_cluster() {
  local PROJECT_ID; PROJECT_ID="${1}"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="${2}"
  local CLUSTER_NAME; CLUSTER_NAME="${3}"

  local RESULT; RESULT=""

  RESULT="$(gcloud container clusters list \
    --project="${PROJECT_ID}" \
    --filter="name = ${CLUSTER_NAME} AND location = ${CLUSTER_LOCATION}" \
    --format="value(name)" || true)"
  if [[ -z "${RESULT}" ]]; then
    { read -r -d '' MSG; validation_error "${MSG}"; } <<EOF || true
Unable to find cluster ${CLUSTER_LOCATION}/${CLUSTER_NAME}.
Please verify the spelling and try again. To see a list of your clusters, in
this project, run:
  gcloud container clusters list --format='value(name,zone)' --project="${PROJECT_ID}"
EOF
  fi
}

validate_k8s() {
  K8S_MINOR="$(kubectl version -o json | jq .serverVersion.minor | sed 's/[^0-9]//g')"; readonly K8S_MINOR
  if [[ "${K8S_MINOR}" -lt 15 ]]; then
    fatal "ASM ${RELEASE} requires Kubernetes version 1.15+, found 1.${K8S_MINOR}"
  fi
}

#######
# validate_node_pool makes sure that the cluster meets ASM's minimum compute
# requirements
#######
validate_node_pool() {
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"
  local MACHINE_CPU_REQ; MACHINE_CPU_REQ=4; readonly MACHINE_CPU_REQ;
  local TOTAL_CPU_REQ; TOTAL_CPU_REQ=8; readonly TOTAL_CPU_REQ;

  info "Confirming node pool requirements for ${PROJECT_ID}/${CLUSTER_LOCATION}/${CLUSTER_NAME}..."
  local ACTUAL_CPU
  ACTUAL_CPU="$(list_valid_pools "${MACHINE_CPU_REQ}" | \
      jq '.[] |
        (if .autoscaling.enabled then .autoscaling.maxNodeCount else .initialNodeCount end)
        *
        (.config.machineType / "-" | .[-1] | try tonumber catch 1)
        * (.locations | length)
      ' 2>/dev/null)" || true

  local MAX_CPU; MAX_CPU=0;
  for i in ${ACTUAL_CPU}; do
    MAX_CPU="$(( i > MAX_CPU ? i : MAX_CPU))"
  done

  if [[ "$MAX_CPU" -lt "$TOTAL_CPU_REQ" ]]; then
    { read -r -d '' MSG; warn_pause "${MSG}"; } <<EOF || true

ASM requires you to have at least ${TOTAL_CPU_REQ} vCPUs in node pools whose
machine type is at least ${MACHINE_CPU_REQ} vCPUs.
${CLUSTER_LOCATION}/${CLUSTER_NAME} does not meet this requirement. ASM
may not function as expected.

EOF
  fi
}

validate_expected_control_plane(){
  info "Checking Istio installations..."
  check_no_istiod_outside_of_istio_system_namespace
}

check_no_istiod_outside_of_istio_system_namespace() {
  local IN_ANY_NAMESPACE IN_NAMESPACE
  IN_ANY_NAMESPACE="$(kubectl get deployment -A --ignore-not-found=true | grep -c istiod || true)";
  IN_NAMESPACE="$(kubectl get deployment -n istio-system --ignore-not-found=true | grep -c istiod || true)";

  if [ "$IN_ANY_NAMESPACE" -gt "$IN_NAMESPACE" ]; then
    { read -r -d '' MSG; validation_error "${MSG}"; } <<EOF || true
found istiod deployment outside of istio-system namespace. This installer
does not support that configuration.
EOF
  fi
}

validate_istio_version() {
  info "Checking existing Istio version(s)..."
  local VERSION_OUTPUT; VERSION_OUTPUT="$(retry 3 istioctl version -o json)"
  if [[ -z "${VERSION_OUTPUT}" ]]; then
    fatal "Couldn't validate existing Istio versions."
  fi
  local FOUND_VALID_VERSION; FOUND_VALID_VERSION=0
  for version in $(echo "${VERSION_OUTPUT}" | jq -r '.meshVersion[].Info.version' -r); do
    if [[ "$version" =~ ^$RELEASE_LINE || "$version" =~ ^$PREVIOUS_RELEASE_LINE ]]; then
      info "  $version (suitable for migration)"
      FOUND_VALID_VERSION=1
    else
      info "  $version (not suitable for migration)"
    fi
    if [[ "$version" =~ "asm" ]]; then
      fatal "Cannot migrate from version $version. Only migration from OSS Istio to the ASM distribution is supported."
    fi
  done
  if [[ "$FOUND_VALID_VERSION" -eq 0 ]]; then
    fatal "Migration requires an existing control plane in the ${RELEASE_LINE} line."
  fi
}

validate_asm_version() {
  info "Checking existing ASM version(s)..."
  local VERSION_OUTPUT; VERSION_OUTPUT="$(retry 3 istioctl version -o json)"
  if [[ -z "${VERSION_OUTPUT}" ]]; then
    fatal "Couldn't validate existing Istio versions."
  fi
  local FOUND_INVALID_VERSION; FOUND_INVALID_VERSION=0
  for VERSION in $(echo "${VERSION_OUTPUT}" | jq -r '.meshVersion[].Info.version'); do
    if ! [[ "${VERSION}" =~ "asm" ]]; then
      fatal "Cannot upgrade from version ${VERSION}. Only upgrades from ASM distributions are supported."
    fi

    if version_valid_for_upgrade "${VERSION}"; then
      info "  ${VERSION} (suitable for migration)"
    else
      info "  ${VERSION} (not suitable for migration)"
      FOUND_INVALID_VERSION=1
    fi
  done
  if [[ "$FOUND_INVALID_VERSION" -eq 1 ]]; then
    fatal "Upgrade requires all existing control planes to be between versions 1.$((MINOR-1)).0 (inclusive) and ${RELEASE} (exclusive)."
  fi
}

validate_ca_consistency() {
  local CURRENT_CA; CURRENT_CA="citadel"
  local CA; CA="$(context_get-option "CA")"

  if is_meshca_installed; then
    CURRENT_CA="mesh_ca"
  elif is_gcp_cas_installed; then
    CURRENT_CA="gcp_cas"
  fi

  info "CA already in use: ${CURRENT_CA}"

  if [[ -z "${CA}" ]]; then
    CA="${CURRENT_CA}"
    context_set-option "CA" "${CA}"
  fi

  if [[ "${CA}" != "${CURRENT_CA}" ]]; then
    fatal "CA cannot be switched while performing upgrade. Please use ${CURRENT_CA} as the CA."
  fi
}

validate_no_ingress_gateway() {
  local CUSTOM_OVERLAY; CUSTOM_OVERLAY="$(context_get-option "CUSTOM_OVERLAY")"
  if [[ "${CUSTOM_OVERLAY}" =~ "legacy-default-ingressgateway" ]]; then
    return
  fi

  local INGRESS_GATEWAY_SVC INGRESS_GATEWAY_DEP
  INGRESS_GATEWAY_SVC="$(kubectl get svc istio-ingressgateway -n istio-system || true)"
  INGRESS_GATEWAY_DEP="$(kubectl get deployments istio-ingressgateway -n istio-system || true)"
  if [[ -z "${INGRESS_GATEWAY_SVC}" && -z "${INGRESS_GATEWAY_DEP}" ]]; then
    return
  fi

  warn "Defaults have changed between previous installation methods and this tool."
  warn "We detected an ASM ingress gateway currently running in the cluster that"
  warn "would be disabled if continuing with default configuration."
  warn "If this is intended, please enter Y. If this is not intended, please enter"
  warn "N and re-run the tool with the '--option legacy-default-ingressgateway'."
  if ! prompt_default_no "Continue?"; then fatal "Stopping installation at user request."; fi
}

exit_if_out_of_iam_policy() {
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local MEMBER_ROLES
  MEMBER_ROLES="$(gcloud projects \
    get-iam-policy "${PROJECT_ID}" \
    --flatten='bindings[].members' \
    --filter="bindings.members:$(local_iam_user)" \
    --format='value(bindings.role)')"

  if [[ "${MEMBER_ROLES}" = *"roles/owner"* ]]; then
    return
  fi

  local REQUIRED; REQUIRED="$(required_iam_roles)";

  local NOTFOUND; NOTFOUND="$(find_missing_strings "${REQUIRED}" "${MEMBER_ROLES}")"

  if [[ -n "${NOTFOUND}" ]]; then
    for role in $(echo "${NOTFOUND}" | tr ',' '\n'); do
      warn "IAM role not enabled - ${role}"
    done
    { read -r -d '' MSG; validation_error "${MSG}"; } <<EOF || true
One or more IAM roles required to install ASM is missing. Please add
${GCLOUD_MEMBER} to the roles above, or run
the script with "--enable_gcp_iam_roles" to allow the script to add
them on your behalf.
$(enable_common_message)
EOF
  fi
}

exit_if_apis_not_enabled() {
  local ENABLED; ENABLED="$(get_enabled_apis)";
  local REQUIRED; REQUIRED="$(required_apis)";
  local NOTFOUND; NOTFOUND="";

  info "Checking required APIs..."
  NOTFOUND="$(find_missing_strings "${REQUIRED}" "${ENABLED}")"

  if [[ -n "${NOTFOUND}" ]]; then
    for api in $(echo "${NOTFOUND}" | tr ' ' '\n'); do
      warn "API not enabled - ${api}"
    done
    { read -r -d '' MSG; validation_error "${MSG}"; } <<EOF || true
One or more APIs are not enabled. Please enable them and retry, or run the
script with the '--enable_gcp_apis' flag to allow the script to enable them on
your behalf.
$(enable_common_message)
EOF
  fi
}

exit_if_cluster_unlabeled() {
  local LABELS; LABELS="$(get_cluster_labels)";
  local REQUIRED; REQUIRED="$(mesh_id_label)";
  local NOTFOUND; NOTFOUND="$(find_missing_strings "${REQUIRED}" "${LABELS}")"

  if [[ -n "${NOTFOUND}" ]]; then
    for label in $(echo "${NOTFOUND}" | tr ',' '\n'); do
      warn "Cluster label not found - ${label}"
    done
    { read -r -d '' MSG; validation_error "${MSG}"; } <<EOF || true
One or more required cluster labels were not found. Please label them and retry,
or run the script with the '--enable_cluster_labels' flag to allow the script
to enable them on your behalf.
$(enable_common_message)
EOF
  fi
}

exit_if_cluster_unregistered() {
  if ! is_cluster_registered; then
    { read -r -d '' MSG; validation_error "${MSG}"; } <<EOF || true
Cluster is not registered to a fleet. Please register the cluster and
retry, or run the script with the '--enable_registration' flag to allow
the script to register to the current project's fleet on your behalf.
EOF
  fi
}

exit_if_no_workload_identity() {
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  if ! is_workload_identity_enabled; then
    { read -r -d '' MSG; validation_error "${MSG}"; } <<EOF || true
Workload identity is not enabled on ${CLUSTER_NAME}. Please enable it and
retry, or run the script with the '--enable_gcp_components' flag to allow
the script to enable it on your behalf.
$(enable_common_message)
EOF
  fi
}

exit_if_stackdriver_not_enabled() {
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  if ! is_stackdriver_enabled; then
    { read -r -d '' MSG; validation_error "${MSG}"; } <<EOF || true
Cloud Operations (Stackdriver)  is not enabled on ${CLUSTER_NAME}.
Please enable it and retry, or run the script with the
'--enable_gcp_components' flag to allow the script to enable it on your behalf.
$(enable_common_message)
EOF
  fi
}

exit_if_not_cluster_admin() {
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  if ! is_user_cluster_admin; then
    { read -r -d '' MSG; validation_error "${MSG}"; } <<EOF || true
Current user must have the cluster-admin role on ${CLUSTER_NAME}.
Please add the cluster role binding and retry, or run the script with the
'--enable_cluster_roles' flag to allow the script to enable it on your behalf.
$(enable_common_message)
EOF
  fi
}

exit_if_service_mesh_feature_not_enabled() {
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  if ! is_service_mesh_feature_enabled; then
    { read -r -d '' MSG; validation_error "${MSG}"; } <<EOF || true
The service mesh feature is not enabled on project ${PROJECT_ID}.
Please run the script with the '--enable_gcp_components' flag to allow the
script to enable it on your behalf.
$(enable_common_message)
EOF
  fi
}

exit_if_istio_namespace_not_exists() {
  info "Checking for istio-system namespace..."
  if ! istio_namespace_exists; then
    { read -r -d '' MSG; validation_error "${MSG}"; } <<EOF || true
The istio-system namespace doesn't exist.
Please create the "istio-system" and retry, or run the script with the
'--enable_namespace_creation' flag to allow the script to enable it on your behalf.
$(enable_common_message)
EOF
  fi
}

exit_if_cluster_registered_to_another_fleet() {
  local PROJECT_ID; PROJECT_ID="${1}"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="${2}"
  local CLUSTER_NAME; CLUSTER_NAME="${3}"
  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"

  local WANT
  WANT="//container.googleapis.com/projects/${PROJECT_ID}/locations/${CLUSTER_LOCATION}/clusters/${CLUSTER_NAME}"
  local LIST
  LIST="$(gcloud container hub memberships list --project "${FLEET_ID}" \
    --format=json | grep "${WANT}")"
  if [[ -z "${LIST}" ]]; then
    { read -r -d '' MSG; validation_error "${MSG}"; } <<EOF || true
Cluster is already registered but not in the project ${FLEET_ID}.
EOF
  fi
}

enable_workload_identity(){
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"

  if is_workload_identity_enabled; then return; fi
  info "Enabling Workload Identity on ${CLUSTER_LOCATION}/${CLUSTER_NAME}..."
  info "(This could take awhile, up to 10 minutes)"
  retry 2 gcloud container clusters update "${CLUSTER_NAME}" \
    --project="${PROJECT_ID}" \
    --zone="${CLUSTER_LOCATION}" \
    --workload-pool="${WORKLOAD_POOL}"
}

enable_stackdriver_kubernetes(){
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"

  info "Enabling Stackdriver on ${CLUSTER_LOCATION}/${CLUSTER_NAME}..."
  retry 2 gcloud container clusters update "${CLUSTER_NAME}" \
    --project="${PROJECT_ID}" \
    --zone="${CLUSTER_LOCATION}" \
    --enable-stackdriver-kubernetes
}

enable_service_mesh_feature() {
  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"

  info "Enabling the service mesh feature..."

  retry 2 run_command gcloud beta container hub mesh enable --project="${FLEET_ID}"
}

check_istio_deployed(){
  local ISTIOD_COUNT; ISTIOD_COUNT="$(get_istio_deployment_count)";

  info "Found ${ISTIOD_COUNT} deployment(s)."
  if [[ "$ISTIOD_COUNT" -eq 0 ]]; then
    warn_pause "no istiod deployment found. (Expected >=1.)"
  fi
}

check_istio_not_deployed(){
  local ISTIOD_COUNT; ISTIOD_COUNT="$(get_istio_deployment_count)";
  if [[ "$ISTIOD_COUNT" -ne 0 ]]; then
    { read -r -d '' MSG; warn_pause "${MSG}"; } <<EOF || true

Install mode specified, but ${ISTIOD_COUNT} existing istiod deployment(s) found. (Expected 0.)
Installation may overwrite existing control planes with the same revision.

EOF
  fi
}

validate_args() {
  ### Option variables ###
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"
  local PLATFORM; PLATFORM="$(context_get-option "PLATFORM")"
  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"
  local CA; CA="$(context_get-option "CA")"
  local CUSTOM_OVERLAY; CUSTOM_OVERLAY="$(context_get-option "CUSTOM_OVERLAY")"
  local OPTIONAL_OVERLAY; OPTIONAL_OVERLAY="$(context_get-option "OPTIONAL_OVERLAY")"
  local ENABLE_ALL; ENABLE_ALL="$(context_get-option "ENABLE_ALL")"
  local ENABLE_CLUSTER_ROLES; ENABLE_CLUSTER_ROLES="$(context_get-option "ENABLE_CLUSTER_ROLES")"
  local ENABLE_CLUSTER_LABELS; ENABLE_CLUSTER_LABELS="$(context_get-option "ENABLE_CLUSTER_LABELS")"
  local ENABLE_GCP_APIS; ENABLE_GCP_APIS="$(context_get-option "ENABLE_GCP_APIS")"
  local ENABLE_GCP_IAM_ROLES; ENABLE_GCP_IAM_ROLES="$(context_get-option "ENABLE_GCP_IAM_ROLES")"
  local ENABLE_GCP_COMPONENTS; ENABLE_GCP_COMPONENTS="$(context_get-option "ENABLE_GCP_COMPONENTS")"
  local ENABLE_REGISTRATION; ENABLE_REGISTRATION="$(context_get-option "ENABLE_REGISTRATION")"
  local ENABLE_NAMESPACE_CREATION; ENABLE_NAMESPACE_CREATION="$(context_get-option "ENABLE_NAMESPACE_CREATION")"
  local DISABLE_CANONICAL_SERVICE; DISABLE_CANONICAL_SERVICE="$(context_get-option "DISABLE_CANONICAL_SERVICE")"
  local PRINT_CONFIG; PRINT_CONFIG="$(context_get-option "PRINT_CONFIG")"
  local SERVICE_ACCOUNT; SERVICE_ACCOUNT="$(context_get-option "SERVICE_ACCOUNT")"
  local KEY_FILE; KEY_FILE="$(context_get-option "KEY_FILE")"
  local CA_CERT; CA_CERT="$(context_get-option "CA_CERT")"
  local CA_KEY; CA_KEY="$(context_get-option "CA_KEY")"
  local CA_ROOT; CA_ROOT="$(context_get-option "CA_ROOT")"
  local CA_CHAIN; CA_CHAIN="$(context_get-option "CA_CHAIN")"
  local CA_NAME; CA_NAME="$(context_get-option "CA_NAME")"
  local DRY_RUN; DRY_RUN="$(context_get-option "DRY_RUN")"
  local ONLY_VALIDATE; ONLY_VALIDATE="$(context_get-option "ONLY_VALIDATE")"
  local ONLY_ENABLE; ONLY_ENABLE="$(context_get-option "ONLY_ENABLE")"
  local VERBOSE; VERBOSE="$(context_get-option "VERBOSE")"
  local MANAGED; MANAGED="$(context_get-option "MANAGED")"
  local LEGACY; LEGACY="$(context_get-option "LEGACY")"
  local MANAGED_SERVICE_ACCOUNT; MANAGED_SERVICE_ACCOUNT="$(context_get-option "MANAGED_SERVICE_ACCOUNT")"
  local PRINT_HELP; PRINT_HELP="$(context_get-option "PRINT_HELP")"
  local PRINT_VERSION; PRINT_VERSION="$(context_get-option "PRINT_VERSION")"
  local CUSTOM_CA; CUSTOM_CA="$(context_get-option "CUSTOM_CA")"
  local USE_HUB_WIP; USE_HUB_WIP="$(context_get-option "USE_HUB_WIP")"
  local USE_VM; USE_VM="$(context_get-option "USE_VM")"
  local HUB_MEMBERSHIP_ID; HUB_MEMBERSHIP_ID="$(context_get-option "HUB_MEMBERSHIP_ID")"
  local CUSTOM_REVISION; CUSTOM_REVISION="$(context_get-option "CUSTOM_REVISION")"
  local WI_ENABLED; WI_ENABLED="$(context_get-option "WI_ENABLED")"
  local CONTEXT; CONTEXT="$(context_get-option "CONTEXT")"
  local KUBECONFIG_SUPPLIED; KUBECONFIG_SUPPLIED="$(context_get-option "KUBECONFIG_SUPPLIED")"
  local CHANNEL; CHANNEL="$(context_get-option "CHANNEL")"

  if is_legacy && ! is_managed; then
      fatal "The --legacy option is only supported with managed control plane."
  fi

  if [[ -z "${CA}" ]]; then
    CA="mesh_ca"
    context_set-option "CA" "${CA}"
  fi

  if [[ "${CUSTOM_REVISION}" -eq 1 ]]; then
    validate_revision_label
  fi

  if is_managed; then
    if [[ "${CA}" == "citadel" ]]; then
      fatal "Citadel is not supported with managed control plane."
    fi

    if [[ "${CUSTOM_CA}" -eq 1 ]]; then
      fatal "Specifying a custom CA with managed control plane is not supported."
    fi

    if [[ "${CUSTOM_REVISION}" -eq 1 ]]; then
      fatal "Specifying a revision label with managed control plane is not supported."
    fi

    if [[ -n "${CUSTOM_OVERLAY}" ]]; then
      fatal "Specifying a custom overlay file with managed control plane is not supported."
    fi
  fi

  if [[ -z "${PLATFORM}" ]]; then
    PLATFORM="gcp"
    context_set-option "PLATFORM" "gcp"
  fi

  case "${PLATFORM}" in
      gcp | multicloud);;
      *) fatal "PLATFORM must be one of 'gcp', 'multicloud'";;
  esac

  if [[ -n "${CHANNEL}" ]]; then
    case "${CHANNEL}" in
      regular | stable | rapid);;
      *) fatal "CHANNEL must be one of 'regular', 'stable', 'rapid'";;
    esac
  fi

  local MISSING_ARGS=0

  local CLUSTER_DETAIL_SUPPLIED=0
  local CLUSTER_DETAIL_VALID=1
  while read -r REQUIRED_ARG; do
    if [[ -z "${!REQUIRED_ARG}" ]]; then
      CLUSTER_DETAIL_VALID=0
    else
      CLUSTER_DETAIL_SUPPLIED=1 # gke cluster param usage intended
    fi
  done <<EOF
PROJECT_ID
CLUSTER_LOCATION
CLUSTER_NAME
EOF

  # Script will not infer the intent between the 2 use cases in case both values are provided
  if [[ "${CLUSTER_DETAIL_SUPPLIED}" -eq 1 && "${KUBECONFIG_SUPPLIED}" -eq 1 ]]; then
    fatal_with_usage "Incompatible arguments. Kubeconfig cannot be used in conjunction with [--cluster_location|--cluster_name|--project_id]."
  fi

  if [[ "${CLUSTER_DETAIL_SUPPLIED}" -eq 1 && "${CLUSTER_DETAIL_VALID}" -eq 0 ]]; then
    MISSING_ARGS=1
    warn "Missing one or more required options for [CLUSTER_LOCATION|CLUSTER_NAME|PROJECT_ID]"
  fi

  if [[ "${CLUSTER_DETAIL_SUPPLIED}" -eq 0 && "${KUBECONFIG_SUPPLIED}" -eq 0 ]]; then
    MISSING_ARGS=1
    warn "At least one of the following is required: 1) --kubeconfig or 2) --cluster_location, --cluster_name, --project_id"
  fi

  if [[ "${KUBECONFIG_SUPPLIED}" -eq 1 && -z "${CONTEXT}" ]]; then
    # set CONTEXT to current-context in the KUBECONFIG
    # or fail-fast if current-context doesn't exist
    CONTEXT="$(kubectl config current-context)"
    if [[ -z "${CONTEXT}" ]]; then
      MISSING_ARGS=1
      warn "Missing current-context in the KUBECONFIG. Please provide context with --context flag or set a current-context in the KUBECONFIG"
    else
      context_set-option "CONTEXT" "${CONTEXT}"
    fi
  fi

  if [[ "${KUBECONFIG_SUPPLIED}" -eq 1 ]]; then
    info "Reading cluster information for ${CONTEXT}"
    local CONTEXT_CLUSTER;
    CONTEXT_CLUSTER="$(kubectl config get-contexts --no-headers | get_context_cluster)"
    validate_kubeconfig_context "${CONTEXT_CLUSTER}"
  fi

  if is_gcp; then
    # when no Fleet Id is provided, default to the cluster's project as the Fleet host.
    if [[ -z "${FLEET_ID}" ]]; then
      FLEET_ID="${PROJECT_ID}"
      context_set-option "FLEET_ID" "${FLEET_ID}"
    fi
  else
    # set Project Id to same as Fleet Id.
    # Project Id will be used to enable APIs if applicable.
    if [[ -n "${FLEET_ID}" ]]; then
      PROJECT_ID="${FLEET_ID}"
      context_set-option "PROJECT_ID" "${PROJECT_ID}"
    fi
  fi

  if can_register_cluster && ! has_value "FLEET_ID"; then
    MISSING_ARGS=1
    warn "Missing FLEET_ID to register the cluster."
  fi

  case "${CA}" in
    citadel | mesh_ca | gcp_cas);;
    "")
      MISSING_ARGS=1
      warn "Missing value for CA"
      ;;
    *) fatal "CA must be one of 'citadel', 'mesh_ca', 'gcp_cas'";;
  esac

  if [[ "${CA}" = "gcp_cas" ]]; then
    validate_private_ca
  elif [[ "${CUSTOM_CA}" -eq 1 ]]; then
    validate_custom_ca
  fi

  if [[ "${MISSING_ARGS}" -ne 0 ]]; then
    fatal_with_usage "Missing one or more required options."
  fi

  while read -r FLAG; do
    if [[ "${!FLAG}" -ne 0 && "${!FLAG}" -ne 1 ]]; then
      fatal "${FLAG} must be 0 (off) or 1 (on) if set via environment variables."
    fi
    readonly "${FLAG}"
  done <<EOF
DRY_RUN
ENABLE_ALL
ENABLE_CLUSTER_ROLES
ENABLE_CLUSTER_LABELS
ENABLE_GCP_APIS
ENABLE_GCP_IAM_ROLES
ENABLE_GCP_COMPONENTS
ENABLE_REGISTRATION
MANAGED
LEGACY
DISABLE_CANONICAL_SERVICE
ONLY_VALIDATE
ONLY_ENABLE
VERBOSE
EOF

  if [[ "${ENABLE_ALL}" -eq 1 || "${ENABLE_CLUSTER_ROLES}" -eq 1 || \
    "${ENABLE_CLUSTER_LABELS}" -eq 1 || "${ENABLE_GCP_APIS}" -eq 1 || \
    "${ENABLE_GCP_IAM_ROLES}" -eq 1 || "${ENABLE_GCP_COMPONENTS}" -eq 1 || \
    "${ENABLE_REGISTRATION}" -eq 1  || "${ENABLE_NAMESPACE_CREATION}" -eq 1 ]]; then
    if [[ "${ONLY_VALIDATE}" -eq 1 ]]; then
      fatal "validation cannot be run with any --enable* flag"
    fi
  elif only_enable; then
    fatal "You must specify at least one --enable* flag with --only_enable"
  fi

  if [[ -n "$SERVICE_ACCOUNT" && -z "$KEY_FILE" || -z "$SERVICE_ACCOUNT" && -n "$KEY_FILE" ]]; then
    fatal "Service account and key file must be used together."
  fi

  # since we cd to a tmp directory, we need the absolute path for the key file
  # and yaml file
  if [[ -f "${KEY_FILE}" ]]; then
    KEY_FILE="$(apath -f "${KEY_FILE}")"
    readonly KEY_FILE
  elif [[ -n "${KEY_FILE}" ]]; then
    fatal "Couldn't find key file ${KEY_FILE}."
  fi

  local ABS_OVERLAYS; ABS_OVERLAYS=""
  while read -d ',' -r yaml_file; do
    if [[ -f "${yaml_file}" ]]; then
      ABS_OVERLAYS="$(apath -f "${yaml_file}"),${ABS_OVERLAYS}"
    elif [[ -n "${yaml_file}" ]]; then
      fatal "Couldn't find yaml file ${yaml_file}."
    fi
  done <<EOF
${CUSTOM_OVERLAY}
EOF
  CUSTOM_OVERLAY="${ABS_OVERLAYS}"
  context_set-option "CUSTOM_OVERLAY" "${CUSTOM_OVERLAY}"

  WORKLOAD_POOL="${PROJECT_ID}.svc.id.goog"; readonly WORKLOAD_POOL
}

validate_kubeconfig_context() {
  local CONTEXT_CLUSTER; CONTEXT_CLUSTER="${1}"

  # we don't get any info from the kubeconfig file if it's via the gateway
  if [[ "${CONTEXT_CLUSTER}" = connectgateway* ]]; then
    context_set-option "KC_VIA_CONNECT" 1
    return
  fi

  IFS="_" read -r _ PROJECT_ID CLUSTER_LOCATION CLUSTER_NAME <<EOF
${CONTEXT_CLUSTER}
EOF
  if is_gcp; then
    context_set-option "PROJECT_ID" "${PROJECT_ID}"
    context_set-option "CLUSTER_LOCATION" "${CLUSTER_LOCATION}"
    context_set-option "CLUSTER_NAME" "${CLUSTER_NAME}"
  fi
}

arg_required() {
  if [[ ! "${2:-}" || "${2:0:1}" = '-' ]]; then
    fatal "Option ${1} requires an argument."
  fi
}

x_validate_install_args() {
  fatal "\"x install\" is now included with the --managed flag in the install command."

  ### Option variables ###
  local PROJECT_ID; PROJECT_ID="$(context_get-option "PROJECT_ID")"
  local CLUSTER_NAME; CLUSTER_NAME="$(context_get-option "CLUSTER_NAME")"
  local CLUSTER_LOCATION; CLUSTER_LOCATION="$(context_get-option "CLUSTER_LOCATION")"
  local MANAGED; MANAGED="$(context_get-option "MANAGED")"
  local LEGACY; LEGACY="$(context_get-option "LEGACY")"
  local FLEET_ID; FLEET_ID="$(context_get-option "FLEET_ID")"
  local CA; CA="$(context_get-option "CA")"
  local ENABLE_ALL; ENABLE_ALL="$(context_get-option "ENABLE_ALL")"
  local ENABLE_CLUSTER_ROLES; ENABLE_CLUSTER_ROLES="$(context_get-option "ENABLE_CLUSTER_ROLES")"
  local ENABLE_CLUSTER_LABELS; ENABLE_CLUSTER_LABELS="$(context_get-option "ENABLE_CLUSTER_LABELS")"
  local ENABLE_GCP_APIS; ENABLE_GCP_APIS="$(context_get-option "ENABLE_GCP_APIS")"
  local ENABLE_GCP_IAM_ROLES; ENABLE_GCP_IAM_ROLES="$(context_get-option "ENABLE_GCP_IAM_ROLES")"
  local ENABLE_GCP_COMPONENTS; ENABLE_GCP_COMPONENTS="$(context_get-option "ENABLE_GCP_COMPONENTS")"
  local ENABLE_REGISTRATION; ENABLE_REGISTRATION="$(context_get-option "ENABLE_REGISTRATION")"
  local ENABLE_NAMESPACE_CREATION; ENABLE_NAMESPACE_CREATION="$(context_get-option "ENABLE_NAMESPACE_CREATION")"
  local USE_VPCSC; USE_VPCSC="$(context_get-option "USE_VPCSC")"
  local DISABLE_CANONICAL_SERVICE; DISABLE_CANONICAL_SERVICE="$(context_get-option "DISABLE_CANONICAL_SERVICE")"
  local PRINT_CONFIG; PRINT_CONFIG="$(context_get-option "PRINT_CONFIG")"
  local SERVICE_ACCOUNT; SERVICE_ACCOUNT="$(context_get-option "SERVICE_ACCOUNT")"
  local KEY_FILE; KEY_FILE="$(context_get-option "KEY_FILE")"
  local DRY_RUN; DRY_RUN="$(context_get-option "DRY_RUN")"
  local ONLY_VALIDATE; ONLY_VALIDATE="$(context_get-option "ONLY_VALIDATE")"
  local ONLY_ENABLE; ONLY_ENABLE="$(context_get-option "ONLY_ENABLE")"
  local VERBOSE; VERBOSE="$(context_get-option "VERBOSE")"
  local MANAGED_SERVICE_ACCOUNT; MANAGED_SERVICE_ACCOUNT="$(context_get-option "MANAGED_SERVICE_ACCOUNT")"
  local PRINT_HELP; PRINT_HELP="$(context_get-option "PRINT_HELP")"
  local PRINT_VERSION; PRINT_VERSION="$(context_get-option "PRINT_VERSION")"
  local CONTEXT; CONTEXT="$(context_get-option "CONTEXT")"
  local KUBECONFIG_SUPPLIED; KUBECONFIG_SUPPLIED="$(context_get-option "KUBECONFIG_SUPPLIED")"
  local CHANNEL; CHANNEL="$(context_get-option "CHANNEL")"

  if [[ -z "${CA}" ]]; then
    CA="mesh_ca"
    context_set-option "CA" "${CA}"
  fi

  local MISSING_ARGS=0

  local CLUSTER_DETAIL_SUPPLIED=0
  local CLUSTER_DETAIL_VALID=1
  while read -r REQUIRED_ARG; do
    if [[ -z "${!REQUIRED_ARG}" ]]; then
      CLUSTER_DETAIL_VALID=0
    else
      CLUSTER_DETAIL_SUPPLIED=1 # gke cluster param usage intended
    fi
  done <<EOF
PROJECT_ID
CLUSTER_LOCATION
CLUSTER_NAME
EOF

  if [[ "${MANAGED}" -eq 0 ]]; then
    fatal "Currently only managed control plane installation is supported by experimental install."
  fi

  if [[ "${LEGACY}" -eq 1 ]]; then
    fatal "The legacy install subcommand is not available in the experimental install command."
  fi

  if [[ -n "${CHANNEL}" ]]; then
    case "${CHANNEL}" in
      regular | stable | rapid);;
      *) fatal "CHANNEL must be one of 'regular', 'stable', 'rapid'";;
    esac
  fi

  # Script will not infer the intent between the 2 use cases in case both values are provided
  if [[ "${CLUSTER_DETAIL_SUPPLIED}" -eq 1 && "${KUBECONFIG_SUPPLIED}" -eq 1 ]]; then
    fatal_with_usage "Incompatible arguments. Kubeconfig cannot be used in conjunction with [--cluster_location|--cluster_name|--project_id]."
  fi

  if [[ "${CLUSTER_DETAIL_SUPPLIED}" -eq 1 && "${CLUSTER_DETAIL_VALID}" -eq 0 ]]; then
    MISSING_ARGS=1
    warn "Missing one or more required options for [CLUSTER_LOCATION|CLUSTER_NAME|PROJECT_ID]"
  fi

  if [[ "${CLUSTER_DETAIL_SUPPLIED}" -eq 0 && "${KUBECONFIG_SUPPLIED}" -eq 0 ]]; then
    MISSING_ARGS=1
    warn "At least one of the following is required: 1) --kubeconfig or 2) --cluster_location, --cluster_name, --project_id"
  fi

  if [[ "${KUBECONFIG_SUPPLIED}" -eq 1 && -z "${CONTEXT}" ]]; then
    # set CONTEXT to current-context in the KUBECONFIG
    # or fail-fast if current-context doesn't exist
    CONTEXT="$(kubectl config current-context)"
    if [[ -z "${CONTEXT}" ]]; then
      MISSING_ARGS=1
      warn "Missing current-context in the KUBECONFIG. Please provide context with --context flag or set a current-context in the KUBECONFIG"
    else
      context_set-option "CONTEXT" "${CONTEXT}"
    fi
  fi

  if [[ "${KUBECONFIG_SUPPLIED}" -eq 1 ]]; then
    info "Reading cluster information for ${CONTEXT}"
    local CONTEXT_CLUSTER;
    CONTEXT_CLUSTER="$(kubectl config get-contexts --no-headers | get_context_cluster)"
    IFS="_" read -r _ PROJECT_ID CLUSTER_LOCATION CLUSTER_NAME <<EOF
${CONTEXT_CLUSTER}
EOF
    if is_gcp; then
      context_set-option "PROJECT_ID" "${PROJECT_ID}"
      context_set-option "CLUSTER_LOCATION" "${CLUSTER_LOCATION}"
      context_set-option "CLUSTER_NAME" "${CLUSTER_NAME}"
    fi
  fi

  if is_gcp; then
    # when no Fleet Id is provided, default to the cluster's project as the Fleet host.
    if [[ -z "${FLEET_ID}" ]]; then
      FLEET_ID="${PROJECT_ID}"
      context_set-option "FLEET_ID" "${FLEET_ID}"
    fi
  else
    # set Project Id to same as Fleet Id.
    # Project Id will be used to enable APIs if applicable.
    if [[ -n "${FLEET_ID}" ]]; then
      PROJECT_ID="${FLEET_ID}"
      context_set-option "PROJECT_ID" "${PROJECT_ID}"
    fi
  fi

  if can_register_cluster && ! has_value "FLEET_ID"; then
    MISSING_ARGS=1
    warn "Missing FLEET_ID to register the cluster."
  fi

  if [[ "${MISSING_ARGS}" -ne 0 ]]; then
    fatal_with_usage "Missing one or more required options."
  fi

  while read -r FLAG; do
    if [[ "${!FLAG}" -ne 0 && "${!FLAG}" -ne 1 ]]; then
      fatal "${FLAG} must be 0 (off) or 1 (on) if set via environment variables."
    fi
    readonly "${FLAG}"
  done <<EOF
DRY_RUN
ENABLE_ALL
ENABLE_CLUSTER_LABELS
ENABLE_GCP_APIS
ENABLE_GCP_IAM_ROLES
ENABLE_GCP_COMPONENTS
ENABLE_REGISTRATION
USE_VPCSC
DISABLE_CANONICAL_SERVICE
ONLY_VALIDATE
ONLY_ENABLE
VERBOSE
EOF

  if [[ "${ENABLE_ALL}" -eq 1 || \
    "${ENABLE_CLUSTER_LABELS}" -eq 1 || "${ENABLE_GCP_APIS}" -eq 1 || \
    "${ENABLE_GCP_IAM_ROLES}" -eq 1 || "${ENABLE_GCP_COMPONENTS}" -eq 1 || \
    "${ENABLE_REGISTRATION}" -eq 1  || "${ENABLE_NAMESPACE_CREATION}" -eq 1 ]]; then
    if [[ "${ONLY_VALIDATE}" -eq 1 ]]; then
      fatal "validation cannot be run with any --enable* flag"
    fi
  elif only_enable; then
    fatal "You must specify at least one --enable* flag with --only_enable"
  fi

  if [[ -n "$SERVICE_ACCOUNT" && -z "$KEY_FILE" || -z "$SERVICE_ACCOUNT" && -n "$KEY_FILE" ]]; then
    fatal "Service account and key file must be used together."
  fi
}

main "${@}"
